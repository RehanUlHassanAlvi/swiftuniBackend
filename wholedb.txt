-- Drop table
-- DROP TABLE public.admins;

create table public.admins (
	id serial4 not null,
	"name" varchar null,
	email varchar not null,
	"password" varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	portal_id int4 null,
	"role" varchar default 'admin'::character varying null,
	transaction_details text null,
	branch_id varchar null,
	constraint admins_pk primary key (id),
	constraint admins_unique unique (email),
	constraint admins_branches_fk foreign key (branch_id) references public.branches(id),
	constraint admins_portal_fk foreign key (portal_id) references public.portal(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.appeared_questions;

create table public.appeared_questions (
	id serial4 not null,
	question_id int4 not null,
	exam_date timestamp not null,
	exam_venue varchar null,
	exam_memory varchar null,
	created_at timestamp default now() null,
	user_id int4 not null,
	constraint appeared_questions_pk primary key (id),
	constraint appeared_questions_fk foreign key (question_id) references public.question(id) on
delete
	cascade,
	constraint appeared_questions_users_fk foreign key (user_id) references public.users(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.attempted_questions;

create table public.attempted_questions (
	id serial4 not null,
	test_question_id int4 null,
	user_id int4 null,
	marks_obtained float4 null,
	users_response text null,
	time_taken int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	is_ptecore bool default false null,
	constraint attempted_questions_pk primary key (id),
	constraint attempted_questions_fk foreign key (test_question_id) references public.test_questions(id) on
delete
	cascade,
	constraint attempted_questions_users_fk foreign key (user_id) references public.users(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.attempted_questions_comment_likes;

create table public.attempted_questions_comment_likes (
	id serial4 not null,
	user_id int4 null,
	attempted_questions_comment_id int4 null,
	created_at timestamp default now() null,
	constraint attempted_questions_comment_likes_pk primary key (id),
	constraint attempted_questions_comment_likes_comments_fk foreign key (attempted_questions_comment_id) references public.attempted_questions_comments(id) on
delete
	cascade on
	update
		cascade,
		constraint attempted_questions_comment_likes_users_fk foreign key (user_id) references public.users(id) on
		delete
			cascade on
			update
				cascade
);
-- Drop table
-- DROP TABLE public.attempted_questions_comments;

create table public.attempted_questions_comments (
	id serial4 not null,
	craeted_at timestamp default now() null,
	user_id int4 null,
	attempted_question_id int4 null,
	attempted_questions_comment varchar not null,
	constraint attempted_questions_comments_pk primary key (id),
	constraint attempted_questions_comments_test_questions_fk foreign key (attempted_question_id) references public.attempted_questions(id) on
delete
	cascade,
	constraint attempted_questions_comments_users_fk foreign key (user_id) references public.users(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.attempted_questions_likes;

create table public.attempted_questions_likes (
	id serial4 not null,
	user_id int4 null,
	attempted_question_id int4 null,
	created_at timestamp default now() null,
	constraint attempted_question_likes_pk primary key (id),
	constraint attempted_question_likes_users_fk foreign key (user_id) references public.users(id) on
delete
	cascade,
	constraint attempted_questions_likes_attempted_questions_fk foreign key (attempted_question_id) references public.attempted_questions(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.bookmarks;

create table public.bookmarks (
	id serial4 not null,
	test_question_id int4 not null,
	user_id int4 not null,
	created_at timestamp default now() null,
	constraint bookmarks_pk primary key (id),
	constraint bookmarks_fk foreign key (test_question_id) references public.test_questions(id) on
delete
	cascade,
	constraint bookmarks_fk_1 foreign key (user_id) references public.users(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.branch_account_transactions;

create table public.branch_account_transactions (
	id varchar default generate_random_string(20) not null,
	admin_id int4 null,
	no_of_accounts_in_transaction varchar null,
	status varchar null,
	created_at timestamp default now() null,
	branch_id varchar null,
	portal_id int4 null,
	constraint branch_account_transactions_pk primary key (id),
	constraint branch_account_transactions_admins_fk foreign key (admin_id) references public.admins(id) on
delete
	cascade,
	constraint branch_account_transactions_branches_fk foreign key (branch_id) references public.branches(id),
	constraint branch_account_transactions_portal_fk foreign key (portal_id) references public.portal(id)
);
-- Drop table
-- DROP TABLE public.branches;

create table public.branches (
	id varchar default generate_random_string(20) not null,
	"name" varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	portal_id int4 null,
	constraint branches_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.bridge_paln_subplans;

create table public.bridge_paln_subplans (
	id varchar default generate_random_string(24) not null,
	plan_id varchar null,
	subplan_id varchar null,
	price_per_account varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	constraint bridge_paln_subplans_pk primary key (id),
	constraint bridge_paln_subplans_plans_for_whitelabels_fk foreign key (plan_id) references public.plans_for_whitelabels(id) on
delete
	cascade,
	constraint bridge_paln_subplans_subplans_for_whitelabels_fk foreign key (subplan_id) references public.subplans_for_whitelabels(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.comment_likes;

create table public.comment_likes (
	id serial4 not null,
	user_id int4 null,
	comment_id int4 null,
	created_at timestamp default now() null,
	constraint comment_likes_pk primary key (id),
	constraint comment_likes_comments_fk foreign key (comment_id) references public."comments"(id) on
delete
	cascade,
	constraint comment_likes_users_fk foreign key (user_id) references public.users(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public."comments";

create table public."comments" (
	id serial4 not null,
	craeted_at timestamp default now() null,
	user_id int4 null,
	test_question_id int4 null,
	"comment" varchar not null,
	comment_img varchar null,
	category varchar null,
	parent_id int4 null,
	constraint comments_pk primary key (id),
	constraint comments_comments_fk foreign key (parent_id) references public."comments"(id) on
delete
	cascade,
	constraint comments_test_questions_fk foreign key (test_question_id) references public.test_questions(id) on
	delete
		cascade,
		constraint comments_users_fk foreign key (user_id) references public.users(id) on
		delete
			cascade
);
-- Drop table
-- DROP TABLE public.countries;

create table public.countries (
	id varchar default generate_random_string(20) not null,
	"name" varchar null,
	currency varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	is_approved bool default false null,
	constraint countries_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.help_center;

create table public.help_center (
	id varchar default generate_random_string(9) not null,
	"name" varchar null,
	link varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	constraint help_center_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.mock_attempted_questions;

create table public.mock_attempted_questions (
	id serial4 not null,
	mock_test_question_id int4 null,
	user_id int4 null,
	marks_obtained float4 null,
	users_response text null,
	time_taken int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	is_ptecore bool default false null,
	mock_test_attempt_id int4 null,
	alltimes text null,
	audio_url varchar null,
	constraint mock_attempted_questions_pk primary key (id),
	constraint mock_attempted_questions_fk foreign key (mock_test_question_id) references public.mock_test_questions(id) on
delete
	cascade,
	constraint mock_attempted_questions_mock_test_attempts_fk foreign key (mock_test_attempt_id) references public.mock_test_attempts(id) on
	delete
		cascade,
		constraint mock_attempted_questions_users_fk foreign key (user_id) references public.users(id) on
		delete
			cascade
);
-- Drop table
-- DROP TABLE public.mock_test;

create table public.mock_test (
	id serial4 not null,
	"name" varchar null,
	total_time int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	order_id int4 null,
	core bool default false null,
	mock_test_type_id int4 null,
	individual_times text null,
	constraint mock_test_unique unique (name),
	constraint newtable_pk primary key (id),
	constraint mock_test_mock_test_types_fk foreign key (mock_test_type_id) references public.mock_test_types(id)
);
-- Drop table
-- DROP TABLE public.mock_test_attempts;

create table public.mock_test_attempts (
	id serial4 not null,
	mock_test_id int4 not null,
	user_id int4 not null,
	start_time timestamp default now() null,
	end_time timestamp null,
	total_marks_obtained varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	status varchar default 'pending'::character varying null,
	analytics json null,
	constraint mock_test_attempts_pk primary key (id),
	constraint mock_test_attempts_mock_test_fk foreign key (mock_test_id) references public.mock_test(id) on
delete
	cascade,
	constraint mock_test_attempts_user_fk foreign key (user_id) references public.users(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.mock_test_id_;

create table public.mock_test_id_ (
	mock_test_id int4 null
);
-- Drop table
-- DROP TABLE public.mock_test_questions;

create table public.mock_test_questions (
	id serial4 not null,
	question_id int4 null,
	order_id int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	mock_test_id int4 null,
	constraint mock_test_questions_pk primary key (id),
	constraint mock_test_questions_mock_test_fk foreign key (mock_test_id) references public.mock_test(id) on
delete
	cascade,
	constraint mock_test_questions_question_id_fk foreign key (question_id) references public.question(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.mock_test_types;

create table public.mock_test_types (
	id serial4 not null,
	"name" varchar null,
	constraint mock_test_types_pk primary key (id)
);
-- Drop table
-- DROP TABLE public."options";

create table public."options" (
	id serial4 not null,
	option_names varchar null,
	answer_names varchar null,
	question_id int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	option_text varchar null,
	constraint options_pk primary key (id),
	constraint options_fk foreign key (question_id) references public.question(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.permission_main_type;

create table public.permission_main_type (
	id serial4 not null,
	main_type_name varchar null,
	created_at timestamp default now() null,
	constraint permission_main_type_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.permission_sub_types;

create table public.permission_sub_types (
	id serial4 not null,
	sub_type_name varchar null,
	created_at timestamp default now() null,
	constraint permission_sub_types_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.permissions;

create table public.permissions (
	id varchar default generate_random_string(10) not null,
	"name" varchar null,
	created_at timestamp default now() null,
	main_type int4 null,
	sub_type int4 null,
	old_id varchar default nextval('permissions_old_id_seq'::regclass) not null,
	constraint permissions_pk primary key (id),
	constraint permissions_permission_main_type_fk foreign key (main_type) references public.permission_main_type(id),
	constraint permissions_permission_sub_types_fk foreign key (sub_type) references public.permission_sub_types(id)
);
-- Drop table
-- DROP TABLE public.permissions_admin;

create table public.permissions_admin (
	id serial4 not null,
	admin_id int4 not null,
	permission_id varchar not null,
	created_at timestamp default now() null,
	constraint permissions_admin_pk primary key (id),
	constraint permissions_admin_admins_fk foreign key (admin_id) references public.admins(id) on
delete
	cascade,
	constraint permissions_admin_permissions_fk foreign key (permission_id) references public.permissions(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.plans_for_whitelabels;

create table public.plans_for_whitelabels (
	id varchar default generate_random_string(24) not null,
	"name" varchar null,
	plan varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	country_id varchar default 'aGAUhqd0rCPrkW5nmpMB'::character varying null,
	days varchar default '30'::character varying null,
	constraint plans_for_whitelabels_pk primary key (id),
	constraint plans_for_whitelabels_countries_fk foreign key (country_id) references public.countries(id)
);
-- Drop table
-- DROP TABLE public.portal;

create table public.portal (
	id serial4 not null,
	portal_link varchar null,
	portal_owner_name varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	facebook_link varchar null,
	whatsapp_link varchar null,
	telegram_link varchar null,
	phone_no varchar null,
	support_email varchar null,
	support_address varchar null,
	portal_logo varchar null,
	portal_favicon varchar null,
	landing_img varchar null,
	strategy_video_visible bool default false null,
	template_visible bool default false null,
	grammar_visible bool default false null,
	self_strategy_video_visible bool default true null,
	self_template_visible bool default true null,
	self_grammar_visible bool default true null,
	"location" varchar null,
	country_id varchar default 'BLnwSIBhCcUKMtUygV3D'::character varying null,
	portal_name varchar null,
	youtube_url varchar null,
	youtube_thumbnail varchar null,
	portal_info varchar null,
	constraint portal_pk primary key (id),
	constraint portal_unique unique (portal_link),
	constraint portal_unique_1 unique (portal_name),
	constraint portal_unique_2 unique (portal_link),
	constraint portal_countries_fk foreign key (country_id) references public.countries(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.prediction_file;

create table public.prediction_file (
	id serial4 not null,
	"name" varchar null,
	file_url varchar null,
	priority int4 null,
	core bool null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	constraint prediction_file_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.promo_codes;

create table public.promo_codes (
	id varchar default generate_random_string(5) not null,
	percentage int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	active bool default true null,
	user_id int4 null,
	fixed_amount int4 null,
	portal_id int4 null,
	count int4 default 1 null,
	temp_count int4 default 0 null,
	expiry_date timestamp null,
	constraint promo_codes_pk primary key (id),
	constraint promo_codes_portal_fk foreign key (portal_id) references public.portal(id),
	constraint promo_codes_users_fk foreign key (user_id) references public.users(id)
);
-- Drop table
-- DROP TABLE public.question;

create table public.question (
	id serial4 not null,
	"name" varchar null,
	"statement" varchar null,
	total_marks int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	major_aspects varchar null,
	minor_aspects varchar null,
	audio_object varchar null,
	test_id int4 default 1 null,
	question_image varchar null,
	time_allowed int4 null,
	prediction bool default false null,
	difficulty varchar null,
	constraint question_pk primary key (id),
	constraint question_test_fk foreign key (test_id) references public.test(id)
);
-- Drop table
-- DROP TABLE public.strategy_video;

create table public.strategy_video (
	id serial4 not null,
	title varchar null,
	author varchar null,
	yt_link varchar null,
	category varchar null,
	priority int4 null,
	"language" varchar null,
	core bool null,
	thumbnail varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	portal_id int4 null,
	constraint strategy_video_pk primary key (id),
	constraint strategy_video_portal_fk foreign key (portal_id) references public.portal(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.subplans_for_whitelabels;

create table public.subplans_for_whitelabels (
	id varchar default generate_random_string(24) not null,
	"name" varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	mock_only bool default false null,
	constraint subplans_for_whitelabels_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.subscriptions;

create table public.subscriptions (
	id varchar default generate_random_string(24) not null,
	"name" varchar null,
	"desc" varchar null,
	price_pkr int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	inactive bool default false null,
	days int4 default 10 null,
	discount varchar null,
	constraint subscriptions_pk primary key (id)
);
-- Drop table
-- DROP TABLE public.templates_and_grammar_pdfs;

create table public.templates_and_grammar_pdfs (
	id serial4 not null,
	"name" varchar null,
	pdf_url varchar null,
	is_template bool null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	portal_id int4 null,
	constraint templates_and_grammar_pdfs_unique unique (id),
	constraint templates_and_grammar_pdfs_portal_fk foreign key (portal_id) references public.portal(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.test;

create table public.test (
	id serial4 not null,
	category_id int4 null,
	test_name varchar not null,
	is_answer_fixed bool null,
	order_id int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	beginning_time int4 null,
	total_time int4 null,
	constraint test_pk primary key (id),
	constraint test_un unique (test_name),
	constraint test_fk foreign key (category_id) references public.test_categories(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.test_categories;

create table public.test_categories (
	id serial4 not null,
	category_name varchar not null,
	order_id int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	constraint test_categories_pk primary key (id),
	constraint test_categories_un unique (category_name)
);
-- Drop table
-- DROP TABLE public.test_question_notes;

create table public.test_question_notes (
	id serial4 not null,
	test_question_id int4 not null,
	user_id int4 not null,
	created_at timestamp default now() null,
	note varchar null,
	constraint test_question_notes_pk primary key (id),
	constraint test_question_notes_fk foreign key (user_id) references public.users(id) on
delete
	cascade,
	constraint test_question_notes_fk_1 foreign key (test_question_id) references public.test_questions(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.test_questions;

create table public.test_questions (
	id serial4 not null,
	test_id int4 null,
	question_id int4 null,
	order_id int4 null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	constraint test_questions_pk primary key (id),
	constraint test_questions_fk foreign key (test_id) references public.test(id) on
delete
	cascade,
	constraint test_questions_question_id_fk foreign key (question_id) references public.question(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.user_transactions;

create table public.user_transactions (
	id varchar default generate_random_string(24) null,
	user_id int4 null,
	subscription_id varchar null,
	status varchar null,
	request_payload varchar null,
	response_payload varchar null,
	bank_alfalah_subscription_id varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	promocode_id varchar null,
	image_url varchar null,
	is_approved bool default false null,
	country varchar null,
	currency varchar default '"PKR"'::character varying null,
	phone varchar null,
	email varchar null,
	portal_id int4 default 1 null,
	order_id varchar null,
	transaction_reference_number varchar null,
	transaction_id varchar null,
	transaction_amount varchar null,
	transaction_description varchar null,
	transaction_status varchar null,
	reference_number varchar null,
	"location" varchar null,
	bought_by_and_reason text null,
	constraint user_transactions_portal_fk foreign key (portal_id) references public.portal(id),
	constraint user_transactions_promo_codes_fk foreign key (promocode_id) references public.promo_codes(id),
	constraint user_transactions_subscriptions_fk foreign key (subscription_id) references public.subscriptions(id),
	constraint user_transactions_users_fk foreign key (user_id) references public.users(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.users;

create table public.users (
	id serial4 not null,
	"name" varchar null,
	email varchar not null,
	"password" varchar null,
	is_email_verified bool default false null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	google_id varchar null,
	country_code varchar null,
	phone_number varchar null,
	is_deleted bool default false null,
	city varchar null,
	image_url varchar null,
	pte_stats jsonb null,
	academic_stats jsonb null,
	last_updated_pte timestamp null,
	last_updated_acadamic timestamp null,
	exam_date timestamp null,
	exam_target text null,
	exam_date_created_at timestamp null,
	portal_id int4 null,
	"type" varchar null,
	student_note varchar null,
	deleted_from_trash bool default false null,
	subscription_id varchar null,
	plan_id varchar null,
	is_subscribed bool default false null,
	non_ai int4 default 20 null,
	speaking int4 default 5 null,
	writing int4 default 3 null,
	subscription_time timestamptz default now() null,
	session_expiry timestamptz default now() null,
	sessionid varchar null,
	branch_id varchar null,
	constraint users_pk primary key (id),
	constraint users_un unique (email),
	constraint users_branches_fk foreign key (branch_id) references public.branches(id),
	constraint users_plans_for_whitelabels_fk foreign key (plan_id) references public.plans_for_whitelabels(id),
	constraint users_portal_fk foreign key (portal_id) references public.portal(id) on
delete
	cascade,
	constraint users_subscriptions_fk foreign key (subscription_id) references public.subscriptions(id)
);
-- Drop table
-- DROP TABLE public.vocab_bank;

create table public.vocab_bank (
	id serial4 not null,
	"name" varchar null,
	"type" varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	user_id int4 null,
	description varchar null,
	constraint vocab_bank_pk primary key (id),
	constraint vocab_bank_users_fk foreign key (user_id) references public.users(id) on
delete
	cascade
);
-- Drop table
-- DROP TABLE public.white_label_total_accounts;

create table public.white_label_total_accounts (
	id serial4 not null,
	portal_id int4 null,
	total_accounts int4 null,
	last_white_label_transaction_id varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	plan_id varchar null,
	assigned int4 default 0 null,
	branches jsonb default '{}'::jsonb null,
	constraint white_label_total_accounts_pk primary key (id),
	constraint white_label_total_accounts_plans_for_whitelabels_fk foreign key (plan_id) references public.plans_for_whitelabels(id),
	constraint white_label_total_accounts_portal_fk foreign key (portal_id) references public.portal(id) on
delete
	cascade,
	constraint white_label_total_accounts_whitelabel_transactions_fk foreign key (last_white_label_transaction_id) references public.whitelabel_transactions(id) on
	delete
		cascade
);
-- Drop table
-- DROP TABLE public.whitelabel_transactions;

create table public.whitelabel_transactions (
	id varchar default generate_random_string(24) not null,
	admin_id int4 null,
	portal_id int4 default 1 null,
	plan_id varchar null,
	status varchar null,
	request_payload varchar null,
	response_payload varchar null,
	bank_alfalah_subscription_id varchar null,
	promocode_id varchar null,
	country varchar null,
	currency varchar default '"PKR"'::character varying null,
	phone varchar null,
	email varchar null,
	order_id varchar null,
	transaction_reference_number varchar null,
	transaction_id varchar null,
	transaction_amount varchar null,
	transaction_description varchar null,
	transaction_status varchar null,
	created_at timestamp default now() null,
	updated_at timestamp null,
	image_url varchar null,
	is_approved bool default false null,
	no_of_accounts_purchased varchar null,
	no_of_accounts_used varchar null,
	amount_paid varchar null,
	reference_number varchar null,
	"location" varchar null,
	bought_by_and_reason text null,
	manual varchar default 'manual'::character varying null,
	constraint whitelabel_transactions_pk primary key (id),
	constraint whitelabel_transactions_admins_fk foreign key (admin_id) references public.admins(id),
	constraint whitelabel_transactions_plans_for_whitelabels_fk foreign key (plan_id) references public.plans_for_whitelabels(id),
	constraint whitelabel_transactions_portal_fk foreign key (portal_id) references public.portal(id) on
delete
	cascade,
	constraint whitelabel_transactions_promo_codes_fk foreign key (promocode_id) references public.promo_codes(id)
);
-- Drop table
-- DROP TABLE public.whitelabel_transactions_account_usage;

create table public.whitelabel_transactions_account_usage (
	id varchar default generate_random_string(24) not null,
	plan_id varchar null,
	user_id int4 null,
	admin_id int4 null,
	created_at timestamp default now() null,
	manual varchar default 'manual'::character varying null,
	constraint whitelabel_transactions_account_usage_pk primary key (id),
	constraint whitelabel_transactions_account_usage_admins_fk foreign key (admin_id) references public.admins(id),
	constraint whitelabel_transactions_account_usage_plans_for_whitelabels_fk foreign key (plan_id) references public.plans_for_whitelabels(id),
	constraint whitelabel_transactions_account_usage_users_fk foreign key (user_id) references public.users(id)
);
-- DROP FUNCTION public.add_admin(varchar, varchar, varchar, int4, _varchar);

create or replace
function public.add_admin("EMAIL" character varying,
"NAME" character varying,
"PASSWORD" character varying,
"PORTALID" integer,
"Permissions" character varying[])
 returns integer
 language plpgsql
as $function$
	declare 
		admin_id_ integer;

begin
		insert
	into
	public.admins(email,
	"name",
	"password",
	portal_id,
	role)
values ($1 ,
$2 ,
pgp_sym_encrypt($3,
'encryptingpassword',
'compress-algo=1'),
$4,
'admin') returning id
into
	admin_id_;

for i in 1.. array_length($5, 1) loop
	        insert
	into
	public.permissions_admin (admin_id,
	permission_id)
values (admin_id_,
$5[i]);
end loop;

return admin_id_;
end;

$function$
;
-- DROP FUNCTION public.add_admin_in_other(varchar, varchar, varchar, int4, _varchar);

create or replace
function public.add_admin_in_other("EMAIL" character varying,
"NAME" character varying,
"PASSWORD" character varying,
"PORTALID" integer,
"Permissions" character varying[])
 returns void
 language plpgsql
as $function$
	declare 
		admin_id_ integer;

begin
		insert
	into
	public.admins(email,
	"name",
	"password",
	portal_id)
values ($1 ,
$2 ,
pgp_sym_encrypt($3,
'encryptingpassword',
'compress-algo=1'),
$4) returning id
into
	admin_id_;

for i in 1.. array_length($5, 1) loop
	        insert
	into
	public.permissions_admin (admin_id,
	permission_id)
values (admin_id_,
$5[i]);
end loop;
end;

$function$
;
-- DROP FUNCTION public.add_appeared_question(int4, timestamp, varchar, varchar, int4);

create or replace
function public.add_appeared_question("QUESTIONID" integer,
"EXAMDATE" timestamp without time zone,
"EXAMVENUE" character varying,
"EXAMMEMORY" character varying,
"USERID" integer)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.appeared_questions (question_id,
	exam_date,
	exam_venue,
	exam_memory,
	user_id)
values($1,
$2,
$3,
$4,
$5);
end;

$function$
;
-- DROP FUNCTION public.add_attempted_question(int4, int4, float4, varchar, int4, bool);

create or replace
function public.add_attempted_question("TESTQUESTIONID" integer,
"USERID" integer,
"MARKSOBTAINED" real,
"USERSRESPONSE" character varying,
"TIMETAKEN" integer,
"ISPTECORE" boolean)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.attempted_questions(
		test_question_id,
		user_id,
		marks_obtained,
		users_response,
		time_taken,
		is_ptecore
		)
values ($1 ,
$2 ,
$3 ,
$4 ,
$5 ,
$6);
end;

$function$
;
-- DROP FUNCTION public.add_attempted_question_like(int4, int4);

create or replace
function public.add_attempted_question_like("USERID" integer,
"ATTEMPTEDQUESTIONID" integer)
 returns table("Status" integer,
"TotalLikes" integer)
 language plpgsql
as $function$
	declare
		status_ integer;

begin
	    if exists (
select
	1
from
	public.attempted_questions_likes
where
	user_id = $1
	and attempted_question_id = $2) then
	        status_ := 0;

return QUERY
	        select
	status_,
	COUNT(*)::integer
from
	public.attempted_questions_likes
where
	attempted_question_id = $2;
else
	        insert
	into
	public.attempted_questions_likes(user_id,
	attempted_question_id)
values ($1,
$2);

status_ := 1;

return QUERY
	        select
	status_,
	COUNT(*)::integer
from
	public.attempted_questions_likes
where
	attempted_question_id = $2;
end if;
end;

$function$
;
-- DROP FUNCTION public.add_attempted_questions_comment(varchar, int4, int4);

create or replace
function public.add_attempted_questions_comment("COMMENT" character varying,
"USERID" integer,
"ATTEMPTEDQUESTIONID" integer)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.attempted_questions_comments(
		attempted_questions_comment,
		user_id,
		attempted_question_id
		)
values ($1 ,
$2 ,
$3);
end;

$function$
;
-- DROP FUNCTION public.add_attempted_questions_comment_like(int4, int4);

create or replace
function public.add_attempted_questions_comment_like("USERID" integer,
"ATTEMPTEDQUESTIONCOMMENTID" integer)
 returns table("Status" integer,
"TotalLikes" integer)
 language plpgsql
as $function$
	declare
		status_ integer;

begin
	    if exists (
select
	1
from
	public.attempted_questions_comment_likes
where
	user_id = $1
	and attempted_questions_comment_id = $2) then
	        status_ := 0;

return QUERY
	        select
	status_,
	COUNT(*)::integer
from
	public.attempted_questions_comment_likes
where
	attempted_questions_comment_id = $2;
else
	        insert
	into
	public.attempted_questions_comment_likes(user_id,
	attempted_questions_comment_id)
values ($1,
$2);

status_ := 1;

return QUERY
	        select
	status_,
	COUNT(*)::integer
from
	public.attempted_questions_comment_likes
where
	attempted_questions_comment_id = $2;
end if;
end;

$function$
;
-- DROP FUNCTION public.add_bookmark(int4, int4);

create or replace
function public.add_bookmark("TESTQUESTIONID" integer,
"USERID" integer)
 returns integer
 language plpgsql
as $function$
declare
    new_id INT;

begin
    delete
from
	public.bookmarks
where
	test_question_id = $1
	and user_id = $2;

insert
	into
	public.bookmarks(test_question_id,
	user_id)
values ($1,
$2)
    returning id
into
	new_id;

return new_id;
end;

$function$
;
-- DROP FUNCTION public.add_branch(varchar, int4);

create or replace
function public.add_branch("NAME" character varying,
"PORTAL_ID" integer)
 returns character varying
 language plpgsql
as $function$
declare
    new_branch_id VARCHAR;

begin
    insert
	into
	public.branches (
        "name",
	portal_id

    )
values (
        $1, 
        $2
    )
    returning id
into
	new_branch_id;

return new_branch_id;
end;

$function$
;
-- DROP FUNCTION public.add_branch_account_transaction(int4, varchar, varchar, varchar, int4);

create or replace
function public.add_branch_account_transaction("ADMINID" integer,
"NOOFACCOUNTSINVOLVEDINTRANSACTION" character varying,
"STATUS" character varying,
"BRANCHID" character varying,
"PORTALID" integer)
 returns character varying
 language plpgsql
as $function$
declare
    transaction_id VARCHAR;

begin
	insert
	into
	public.branch_account_transactions
	(
		admin_id,
		no_of_accounts_in_transaction,
		status,
		branch_id,
		portal_id
	)
values
	(
		$1,
		$2,
		$3,
		$4,
		$5
	) returning id
into
	transaction_id;

return transaction_id;
end;

$function$
;
-- DROP FUNCTION public.add_comment(varchar, varchar, varchar, int4, int4, int4);

create or replace
function public.add_comment("COMMENT" character varying,
"COMMENTIMG" character varying,
"CATEGORY" character varying,
"USERID" integer,
"TESTQUESTIONID" integer,
"PARENTID" integer)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.comments(
		comment,
		comment_img,
		category,
		user_id,
		test_question_id,
		parent_id		
		)
values ($1 ,
$2 ,
$3 ,
$4 ,
$5 ,
$6);
end;

$function$
;
-- DROP FUNCTION public.add_comment_like(int4, int4);

create or replace
function public.add_comment_like("USERID" integer,
"COMMENTID" integer)
 returns table("Status" integer,
"TotalLikes" integer)
 language plpgsql
as $function$
	declare
		status_ integer;

begin
	    if exists (
select
	1
from
	public.comment_likes
where
	user_id = $1
	and comment_id = $2) then
	        status_ := 0;

return QUERY
	        select
	status_,
	COUNT(*)::integer
from
	public.comment_likes
where
	comment_id = $2;
else
	        insert
	into
	public.comment_likes(user_id,
	comment_id)
values ($1,
$2);

status_ := 1;

return QUERY
	        select
	status_,
	COUNT(*)::integer
from
	public.comment_likes
where
	comment_id = $2;
end if;
end;

$function$
;
-- DROP FUNCTION public.add_country(varchar, varchar);

create or replace
function public.add_country("NAME" character varying,
"CURRENCY" character varying)
 returns character varying
 language plpgsql
as $function$
	declare 
		country_id_ varchar;

inserted_plan RECORD;

subplan_ids varchar[] := array['ceC33WRWsfx4XNCRSQRLVpo5',
'1b7C3735eG8WNNGWcPwBOiLf',
'4i4TNq6vu9slxypaUaO3a0XA'];

subplan_id varchar;

begin
	insert
	into
	public.countries("name",
	currency)
values ($1,
$2) returning id
	into
		country_id_;

if country_id_ is not null then
    for inserted_plan in
        insert
	into
	public.plans_for_whitelabels ("name",
	plan,
	country_id,
	days)
values
        ('plan1',
'subscription in days 30',
country_id_,
30),
        ('plan1',
'subscription in days 60',
country_id_,
60),
        ('plan1',
'subscription in days 90',
country_id_,
90),
        ('plan1',
'subscription in days 180',
country_id_,
180),
        ('plan1',
'subscription in days 365',
country_id_,
365),
        ('plan2',
'subscription in days 30',
country_id_,
30),
        ('plan2',
'subscription in days 60',
country_id_,
60),
        ('plan2',
'subscription in days 90',
country_id_,
90),
        ('plan2',
'subscription in days 180',
country_id_,
180),
        ('plan2',
'subscription in days 365',
country_id_,
365)
        returning id
        loop
-- Iterate over each subplan ID and insert into bridge table
            foreach subplan_id in array subplan_ids
            loop
                insert
	into
	public.bridge_paln_subplans
                (plan_id,
	subplan_id,
	price_per_account)
values (inserted_plan.id,
subplan_id,
0);
end loop;
end loop;
end if;

return country_id_;
end;

$function$
;
-- DROP FUNCTION public.add_edit_test_question_note(int4, int4, varchar);

create or replace
function public.add_edit_test_question_note("TESTQUESTIONID" integer,
"USERID" integer,
"NOTE" character varying)
 returns integer
 language plpgsql
as $function$
	begin
		if exists (
select
	1
from
	public.test_question_notes tqn
where
	tqn.test_question_id = $1
	and tqn.user_id = $2) then 
			update
	public.test_question_notes
set
	note = $3
where
	test_question_id = $1
	and user_id = $2;

return 1;
else
			insert
	into
	public.test_question_notes(test_question_id,
	user_id,
	note)
values ($1 ,
$2 ,
$3);

return -1;
end if;

return 0;
end;

$function$
;
-- DROP FUNCTION public.add_help_center(varchar, varchar);

create or replace
function public.add_help_center("NAME" character varying,
"LINK" character varying)
 returns character varying
 language plpgsql
as $function$
declare
    help_center_id_ varchar;

begin
    insert
	into
	public.help_center("name",
	link,
	created_at)
values ($1,
$2,
now())
    returning id
into
	help_center_id_;

return help_center_id_;
end;

$function$
;
-- DROP FUNCTION public.add_in_whitelabel_transactions_account_usage(varchar, int4, int4, varchar);

create or replace
function public.add_in_whitelabel_transactions_account_usage("PLANID" character varying,
"USERID" integer,
"ADMINID" integer,
"MANUAL" character varying)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.whitelabel_transactions_account_usage(
			plan_id,
			user_id,
			admin_id,
			manual
		)
values
		($1,
$2,
$3,
$4);
end;

$function$
;
-- DROP FUNCTION public.add_mock_attempted_question(int4, int4, float4, varchar, int4, bool, int4, text, varchar);

create or replace
function public.add_mock_attempted_question("MOCKTESTQUESTIONID" integer,
"USERID" integer,
"MARKSOBTAINED" real,
"USERSRESPONSE" character varying,
"TIMETAKEN" integer,
"ISPTECORE" boolean,
"MOCKTESTATTEMPTEDID" integer,
"ALLTIMES" text,
"AUDIOURL" character varying)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.mock_attempted_questions(
		mock_test_question_id,
		user_id,
		marks_obtained,
		users_response,
		time_taken,
		is_ptecore,
		mock_test_attempt_id,
		alltimes,
		audio_url
		)
values ($1 ,
		$2 ,
		$3 ,
		$4 ,
		$5 ,
		$6 ,
		$7 ,
		$8 ,
		$9 
		);
end;

$function$
;
-- DROP FUNCTION public.add_mock_attempted_question_timeout(int4, int4, bool, text);

create or replace
function public.add_mock_attempted_question_timeout("MOCKTESTATTEMPTEDID" integer,
"USERID" integer,
"ISPTECORE" boolean,
"RESPONSEOBJECT" text)
 returns void
 language plpgsql
as $function$
declare
    response_data jsonb;

single_response jsonb;

i integer;

begin
-- Parsing the stringified JSON into a jsonb object
response_data := $4::jsonb;
-- Print console response data
    raise notice 'Response Data: %',
response_data;
-- Extracting the response object array
    if response_data is not null then
        for i in 0 .. jsonb_array_length(response_data) - 1 loop
-- Extracting individual response object
single_response := (response_data->i)::jsonb;
-- Print console individual response object
            raise notice 'Individual Response Object: %',
single_response;

insert
	into
	public.mock_attempted_questions(
                mock_test_question_id,
	user_id,
	marks_obtained,
	users_response,
	time_taken,
	is_ptecore,
	mock_test_attempt_id
            )
values (
                (single_response->>'MockTestQuestionTableId')::integer,
                $2,
                0,
                single_response,
                0,
                $3,
                $1
            );
end loop;
end if;
end;

$function$
;
-- DROP FUNCTION public.add_mock_test(varchar, int4, bool, int4, text);

create or replace
function public.add_mock_test("MOCKTESTNAME" character varying,
"MOCKTESTTOTALTIME" integer,
"ISPTECORE" boolean,
"MOCKTESTTYPEID" integer,
"INDIVIDUALTIMES" text)
 returns integer
 language plpgsql
as $function$
	declare 
		mock_test_id_ integer;

begin
		insert
	into
	public.mock_test
		(name,
	total_time,
	order_id ,
	core ,
	mock_test_type_id,
	individual_times)
values($1,
$2,
coalesce((
select
	MAX(order_id)
from
	public.mock_test),
0) + 1 ,
$3,
$4,
$5)
		returning id
into
	mock_test_id_;

return mock_test_id_;
end;

$function$
;
-- DROP FUNCTION public.add_mock_test(varchar, int4, bool, int4);

create or replace
function public.add_mock_test("MOCKTESTNAME" character varying,
"MOCKTESTTOTALTIME" integer,
"ISPTECORE" boolean,
"MOCKTESTTYPEID" integer)
 returns integer
 language plpgsql
as $function$
	declare 
		mock_test_id_ integer;

begin
		insert
	into
	public.mock_test
		(name,
	total_time,
	order_id ,
	core ,
	mock_test_type_id)
values($1,
$2,
coalesce((
select
	MAX(order_id)
from
	public.mock_test),
0) + 1 ,
$3,
$4)
		returning id
into
	mock_test_id_;

return mock_test_id_;
end;

$function$
;
-- DROP FUNCTION public.add_mock_test_questions(int4, _int4);

create or replace
function public.add_mock_test_questions("MOCKTESTID" integer,
"QUESTIONIDs" integer[])
 returns void
 language plpgsql
as $function$
begin
	delete
from
	public.mock_test_questions
where
	mock_test_id = $1;

for i in 1.. array_length($2, 1) loop
            insert
	into
	public.mock_test_questions
                (mock_test_id,
	question_id,
	order_id)
values
                ($1,
$2[i],
coalesce((
select
	MAX(order_id)
from
	public.test),
0) + i);
end loop;
end;

$function$
;
-- DROP FUNCTION public.add_option(varchar, varchar, int4, varchar);

create or replace
function public.add_option("OPTIONNAMES" character varying,
"ANSWERNAMES" character varying,
"QUESTIONID" integer,
"OPTIONTEXT" character varying)
 returns void
 language plpgsql
as $function$
	begin
		delete
from
	public."options"
where
	question_id = $3;

insert
	into
	public."options"
		(option_names,
	answer_names,
	question_id ,
	option_text)
values($1,
$2,
$3,
$4);
end;

$function$
;
-- DROP FUNCTION public.add_permissions_against_admin(_varchar, int4);

create or replace
function public.add_permissions_against_admin("PERMISSIONS" character varying[],
"ADMINID" integer)
 returns integer
 language plpgsql
as $function$
declare
	permission_id character varying;

begin
		
		delete
from
	public.permissions_admin
where
	admin_id = $2;

foreach permission_id in array "PERMISSIONS"
	loop
		insert
	into
	public.permissions_admin (admin_id,
	permission_id,
	created_at)
values ("ADMINID",
permission_id,
now());
end loop;
-- Return success indicator, e.g., number of permissions added
	return array_length("PERMISSIONS",
1);
end;

$function$
;
-- DROP FUNCTION public.add_portal(varchar, varchar, varchar, varchar, varchar);

create or replace
function public.add_portal("PORTALLINK" character varying,
"PORTALOWNERNAME" character varying,
"LOCATION" character varying,
"COUNTRYID" character varying,
"PORTALNAME" character varying)
 returns integer
 language plpgsql
as $function$
	declare 
		portal_id_ integer;

begin
		insert
	into
	public.portal(
			portal_link,
			portal_owner_name,
			location,
	country_id,
	portal_name			
		)
values ($1 ,
$2,
$3,
$4,
$5
) returning id
into
	portal_id_;

return portal_id_;
end;

$function$
;
-- DROP FUNCTION public.add_prediction_file(varchar, varchar, int4, bool);

create or replace
function public.add_prediction_file("NAME" character varying,
"FILEURL" character varying,
"PRIORITY" integer,
"CORE" boolean)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.prediction_file(
		name,
		file_url,
		priority,
		core
		)
values ($1 ,
$2 ,
$3,
$4);
end;

$function$
;
-- DROP FUNCTION public.add_promo_code(int4, int4, int4, int4, int4, timestamp, varchar);

create or replace
function public.add_promo_code("PERCENTAGE" integer,
"USERID" integer,
"FIXEDAMOUNT" integer,
"PORTALID" integer,
"COUNT" integer,
"EXPIRYDATE" timestamp without time zone,
"NAME" character varying)
 returns character varying
 language plpgsql
as $function$
declare
    promo_code_id_ varchar;

adjusted_count integer;

promo_code_id_generate varchar;

begin
    if $5 is null then
        adjusted_count := 1;
else
        adjusted_count := $5;
end if;

if $7 is null then
        promo_code_id_generate := public.generate_random_string(5);
else
        promo_code_id_generate := $7;
end if;

insert
	into
	public.promo_codes(percentage,
	user_id,
	fixed_amount,
	portal_id,
	count,
	expiry_date,
	id)
values ($1,
$2,
$3,
$4,
adjusted_count,
$6,
promo_code_id_generate) returning id
into
	promo_code_id_;

return promo_code_id_;
end;

$function$
;
-- DROP FUNCTION public.add_question(varchar, varchar, int4, varchar, varchar, varchar, int4, varchar, bool, varchar);

create or replace
function public.add_question("QUESTIONNAME" character varying,
"QUESTIONSTATEMENT" character varying,
"TOTALMARKS" integer,
"AUDIOOBJECT" character varying,
"MAJORASPECTS" character varying,
"MINORASPECTS" character varying,
"TESTIDFORCATEGORY" integer,
"QUESTIONIMAGE" character varying,
"PREDICTION" boolean,
"DIFFIULTY" character varying)
 returns integer
 language plpgsql
as $function$
	declare
		new_question_id INT;

begin
		insert
	into
	public.question
		("name",
	"statement",
	total_marks ,
	audio_object,
	major_aspects,
	minor_aspects ,
	test_id,
	question_image,
	prediction,
	difficulty
)
values($1,
$2,
$3 ,
$4 ,
$5 ,
$6 ,
$7 ,
$8 ,
$9,
$10)
		returning id
into
	new_question_id;

insert
	into
	public.test_questions
        (test_id,
	question_id,
	order_id)
values
        ($7,
new_question_id ,
coalesce((
select
	MAX(order_id)
from
	public.test_questions),
0) + 1);

return new_question_id;
end;

$function$
;
-- DROP FUNCTION public.add_strategy_video(varchar, varchar, varchar, varchar, int4, varchar, bool, varchar, int4);

create or replace
function public.add_strategy_video("TITLE" character varying,
"AUTHOR" character varying,
"YT_LINK" character varying,
"CATEGORY" character varying,
"PRIORITY" integer,
"LANGUAGE" character varying,
"CORE" boolean,
"THUMBNAIL" character varying,
"PORTALID" integer)
 returns void
 language plpgsql
as $function$
begin
	insert
	into
	public.strategy_video(
		title,
		author,
		yt_link,
		category,
		priority,
		"language",
		core,
		thumbnail,
		portal_id
	)
values (
		$1,
$2,
$3,
$4,
$5,
$6,
$7,
$8 ,
$9
	);
end;

$function$
;
-- DROP FUNCTION public.add_student_by_admin(varchar, varchar, varchar, int4, varchar, varchar, varchar, varchar);

create or replace
function public.add_student_by_admin("NAME" character varying,
"EMAIL" character varying,
"PASSWORD" character varying,
"PORTALID" integer,
"TYPE" character varying,
"TARGET" character varying,
"NOTE" character varying,
"IMAGEOFUSER" character varying)
 returns table("UserId" integer,
"PortalName" character varying)
 language plpgsql
as $function$
	declare 
		user_id integer;

portal_name_ character varying;

begin
-- Check if the email exists in a different portal
    select
	u.id,
	p.portal_link 
    into
	user_id,
	portal_name_
from
	public.users u
left join public.portal p on
	u.portal_id = p.id
where
	u.email = $2
	and u.portal_id <> $4;

if found then
-- Return the user if found
        return QUERY
        select
	user_id,
	portal_name_;

return;
end if;

insert
	into
	public.users(name,
	email,
	password,
	portal_id,
	type,
	exam_target,
	student_note,
	image_url,
	is_email_verified)
values($1,
$2,
pgp_sym_encrypt($3,
'encryptingpassword',
'compress-algo=1'),
$4,
$5,
$6,
$7,
$8,
true)
		returning id
into
	user_id
		;

return query
		select
	user_id,
	null::character varying;
end;

$function$
;
-- DROP FUNCTION public.add_subscription(varchar, varchar, int4, int4, varchar);

create or replace
function public.add_subscription("NAME" character varying,
"DESC" character varying,
"PRICE_PKR" integer,
"Days" integer,
"DISCOUNT" character varying)
 returns character varying
 language plpgsql
as $function$
	declare 
		subscription_id_ varchar;

begin
		insert
	into
	public.subscriptions("name",
	"desc",
	price_pkr,
	days,
	discount)
values ($1,
$2,
$3,
$4 ,
$5) returning id
into
	subscription_id_;

return subscription_id_;
end;

$function$
;
-- DROP FUNCTION public.add_template_grammar_pdf(varchar, varchar, bool, int4);

create or replace
function public.add_template_grammar_pdf("NAME" character varying,
"PDFURL" character varying,
"ISTEMPLATE" boolean,
"PORTALID" integer)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.templates_and_grammar_pdfs(
		name,
		pdf_url,
		is_template,
		portal_id
		)
values ($1 ,
$2 ,
$3 ,
$4);
end;

$function$
;
-- DROP FUNCTION public.add_test(int4, varchar, bool, int4, int4);

create or replace
function public.add_test("CATEGORYID" integer,
"TESTNAME" character varying,
"ISANSWERFIXED" boolean,
"BEGINNINGTIME" integer,
"TOTALTIME" integer)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.test
		(category_id,
	test_name,
	is_answer_fixed,
	order_id,
	beginning_time,
	total_time)
values($1,
$2,
$3,
coalesce((
select
	MAX(order_id)
from
	public.test),
0) + 1,
$4,
$5);
end;

$function$
;
-- DROP FUNCTION public.add_test_category(varchar);

create or replace
function public.add_test_category("CATEGORYNAME" character varying)
 returns void
 language plpgsql
as $function$
	begin
	    insert
	into
	public.test_categories
	    (category_name,
	order_id)
values($1,
coalesce((
select
	MAX(order_id)
from
	public.test_categories),
0) + 1);
end;

$function$
;
-- DROP FUNCTION public.add_test_questions(int4, _int4);

create or replace
function public.add_test_questions("TESTID" integer,
"QUESTIONIDs" integer[])
 returns void
 language plpgsql
as $function$
begin
	delete
from
	public.test_questions
where
	test_id = $1;

for i in 1.. array_length($2, 1) loop
            insert
	into
	public.test_questions
                (test_id,
	question_id,
	order_id)
values
                ($1,
$2[i],
coalesce((
select
	MAX(order_id)
from
	public.test_questions),
0) + i);
end loop;
end;

$function$
;
-- DROP FUNCTION public.add_user(varchar, varchar, varchar, varchar, varchar);

create or replace
function public.add_user("NAME" character varying,
"EMAIL" character varying,
"PASSWORD" character varying,
"COUNTRYCODE" character varying,
"PHONENUMBER" character varying)
 returns table("UserId" integer)
 language plpgsql
as $function$
	declare 
		user_id integer;

begin
		insert
	into
	public.users(name,
	email,
	password,
	country_code,
	phone_number)
values($1,
$2,
pgp_sym_encrypt($3,
'encryptingpassword',
'compress-algo=1'),
$4,
$5)
		returning id
into
	user_id
		;

return query
		select
	user_id;
end;

$function$
;
-- DROP FUNCTION public.add_user(varchar, varchar, varchar, varchar, varchar, int4);

create or replace
function public.add_user("NAME" character varying,
"EMAIL" character varying,
"PASSWORD" character varying,
"COUNTRYCODE" character varying,
"PHONENUMBER" character varying,
"PORTALID" integer)
 returns table("UserId" integer,
"PortalName" character varying)
 language plpgsql
as $function$
	declare 
		user_id integer;

portal_name_ character varying;

begin
-- Check if the email exists in a different portal
    select
	u.id,
	p.portal_link 
    into
	user_id,
	portal_name_
from
	public.users u
left join public.portal p on
	u.portal_id = p.id
where
	u.email = $2
	and u.portal_id <> $6;

if found then
-- Return the user if found
        return QUERY
        select
	user_id,
	portal_name_;

return;
end if;

insert
	into
	public.users(name,
	email,
	password,
	country_code,
	phone_number,
	portal_id)
values($1,
$2,
pgp_sym_encrypt($3,
'encryptingpassword',
'compress-algo=1'),
$4,
$5,
$6)
		returning id
into
	user_id
		;

return query
		select
	user_id,
	portal_name_;
end;

$function$
;
-- DROP FUNCTION public.add_user_transaction(int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar, bool, varchar, varchar, varchar, varchar, int4, varchar, varchar);

create or replace
function public.add_user_transaction("USERID" integer,
"SUBSCRIPTION_ID" character varying,
"STATUS" character varying,
"REQUESTPAYLOAD" character varying,
"RESPONSEPAYLOAD" character varying,
"BANKALFALAHSUBSCRIPTIONID" character varying,
"PROMOCODE" character varying,
"IMAGEOFRECIEPT" character varying,
"ISAPPROVED" boolean,
"COUNTRY" character varying,
"CURRENCY" character varying,
"PHONE" character varying,
"EMAIL" character varying,
"PORTALID" integer,
"REFERENCENUMBER" character varying,
"LOCATION" character varying)
 returns character varying
 language plpgsql
as $function$
    declare
        transaction_id_ varchar;

begin
        insert
	into
	public.user_transactions(
            user_id,
	subscription_id,
	status,
	request_payload,
	response_payload,
	bank_alfalah_subscription_id,
			promocode_id,
			image_url,
			is_approved,
			country,
			currency,
			phone,
			email,
			portal_id,
			reference_number,
			location
        )
values (
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            $7,
            $8,
            $9,
            $10,
            $11,
            $12,
            $13,
			$14,
			$15,
			$16
        )
        returning id
into
	transaction_id_;

if transaction_id_ is not null then
			update
	public.promo_codes
set
	temp_count = temp_count + 1
where
	id = $7;
end if;

return transaction_id_;
end;

$function$
;
-- DROP FUNCTION public.add_user_transaction_alfalah(int4, varchar, varchar, varchar, varchar, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar);

create or replace
function public.add_user_transaction_alfalah("USERID" integer,
"SUBSCRIPTION_ID" character varying,
"STATUS" character varying,
"RESPONSEPAYLOAD" character varying,
"PROMOCODE" character varying,
"PHONE" character varying,
"PORTALID" integer,
"ORDERID" character varying,
"TRANSACTIONREFERENCENUMBER" character varying,
"TRANSACTIONID" character varying,
"TRANSACTIONAMOUNT" character varying,
"TRANSACTIONDESCRIPTION" character varying,
"TRANSACTIONSTATUS" character varying,
"LOCATION" character varying)
 returns table("TransactionID" character varying,
"UTC" timestamp with time zone)
 language plpgsql
as $function$
declare
    transaction_id_ character varying;

utc_time timestamptz;

begin
-- Insert data into user_transactions and retrieve the transaction ID
    insert
	into
	public.user_transactions(
        user_id,
	subscription_id,
	status,
	response_payload,
	promocode_id,
	is_approved,
	phone,
	portal_id,
	order_id,
	transaction_reference_number,
	transaction_id,
	transaction_amount,
	transaction_description,
	transaction_status,
	reference_number,
	location
    )
values (
        $1,
        $2,
        $3,
        $4,
        $5,
        true,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        public.generate_random_string(24),
        $14
    )
    returning id
into
	transaction_id_;
-- Update promo_codes if PROMOCODE is provided
    if transaction_id_ is not null
and $5 is not null then
        update
	public.promo_codes
set
	temp_count = temp_count - 1,
	count = count - 1
where
	id = $5;
end if;
-- Check transaction status and update user subscription if 'Paid'
    if $13 = 'Paid' then
        update
	public.users
set
	is_subscribed = true,
	subscription_id = $2,
	subscription_time = NOW()
where
	id = $1;
-- Retrieve the updated UTC subscription time
        select
	transaction_id_,
	((u.subscription_time + (s.days || ' days')::interval) at TIME zone 'UTC')::timestamptz
into
	transaction_id_,
	utc_time
from
	public.users u
left join public.subscriptions s on
	u.subscription_id = s.id
where
	u.id = $1;
else
-- Set default null values if the transaction was not 'Paid'
transaction_id_ := null;

utc_time := null;
end if;

return QUERY
select
	transaction_id_,
	utc_time;
end;

$function$
;
-- DROP FUNCTION public.add_user_with_google(varchar, varchar, varchar, int4);

create or replace
function public.add_user_with_google("EMAIL" character varying,
"NAME" character varying,
"GOOGLEID" character varying,
"PORTALID" integer)
 returns table("Status" integer,
"UserId" integer)
 language plpgsql
as $function$
  declare
	  user_info public.users;

user_id integer;

begin
	  select
	*
into
	user_info
from
	public.users
where
	email = $1
	and portal_id = $4;

if user_info is null then
-- User does not exist, so insert a new user
		  insert
	into
	public.users(email,
	"name",
	google_id,
	is_email_verified,
	portal_id)
values ($1,
$2,
$3,
true,
$4) returning id
into
	user_id;

return QUERY
select
	0 as "Status" ,
	user_id;

elsif user_info.google_id is null then
-- User exists but google_id is null, update the user's information
		  update
	public.users
set
	google_id = $3,
	is_email_verified = true
where
	email = $1;

return QUERY
select
	1 as "Status" ,
	user_info.id;
else
-- User exists and google_id is not null
		  return QUERY
select
	2 as "Status",
	user_info.id;
end if;
end;

$function$
;
-- DROP FUNCTION public.add_user_with_google(varchar, varchar, varchar);

create or replace
function public.add_user_with_google("EMAIL" character varying,
"NAME" character varying,
"GOOGLEID" character varying)
 returns table("Status" integer,
"UserId" integer)
 language plpgsql
as $function$
  declare
	  user_info public.users;

user_id integer;

begin
	  select
	*
into
	user_info
from
	public.users
where
	email = $1;

if user_info is null then
-- User does not exist, so insert a new user
		  insert
	into
	public.users(email,
	"name",
	google_id,
	is_email_verified)
values ($1,
$2,
$3,
true) returning id
into
	user_id;

return QUERY
select
	0 as "Status" ,
	user_id;

elsif user_info.google_id is null then
-- User exists but google_id is null, update the user's information
		  update
	public.users
set
	google_id = $3,
	is_email_verified = true
where
	email = $1;

return QUERY
select
	1 as "Status" ,
	user_info.id;
else
-- User exists and google_id is not null
		  return QUERY
select
	2 as "Status";
end if;
end;

$function$
;
-- DROP FUNCTION public.add_vocab(varchar, varchar, int4, varchar);

create or replace
function public.add_vocab("NAME" character varying,
"TYPE" character varying,
"USERID" integer,
"DESCRIPTION" character varying)
 returns void
 language plpgsql
as $function$
	begin
		insert
	into
	public.vocab_bank("name",
	type,
	user_id,
	description)
values ($1 ,
$2 ,
$3 ,
$4);
end;

$function$
;
-- DROP FUNCTION public.add_white_label_total_account(int4, varchar, int4, varchar);

create or replace
function public.add_white_label_total_account("PORTALID" integer,
"PLANID" character varying,
"TOTALACCOUNTS" integer,
"LASTTRANSACTIONID" character varying)
 returns integer
 language plpgsql
as $function$
declare
    white_label_total_account_id_ integer;

begin
-- Check if the record already exists
    select
	id
into
	white_label_total_account_id_
from
	public.white_label_total_accounts
where
	portal_id = $1
	and plan_id = $2;

if white_label_total_account_id_ is not null then
-- If it exists, update the record
        update
	public.white_label_total_accounts
set
	total_accounts = total_accounts + $3,
	last_white_label_transaction_id = $4
where
	id = white_label_total_account_id_;
else
-- If it doesn't exist, insert a new record
        insert
	into
	public.white_label_total_accounts(
            portal_id,
	plan_id,
	total_accounts,
	last_white_label_transaction_id
        )
values ($1,
$2,
$3,
$4)
        returning id
into
	white_label_total_account_id_;
end if;
-- Return the ID of the inserted or updated record
    return white_label_total_account_id_;
end;

$function$
;
-- DROP FUNCTION public.add_whitelabel_transaction(int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, int4, varchar, varchar, varchar);

create or replace
function public.add_whitelabel_transaction("ADMINID" integer,
"PLANID" character varying,
"STATUS" character varying,
"REQUESTPAYLOAD" character varying,
"RESPONSEPAYLOAD" character varying,
"BANKALFALAHSUBSCRIPTIONID" character varying,
"PROMOCODE" character varying,
"COUNTRY" character varying,
"CURRENCY" character varying,
"PHONE" character varying,
"EMAIL" character varying,
"ORDERID" character varying,
"TRANSACTIONREFERENCENUMBER" character varying,
"TRANSACTIONID" character varying,
"TRANSACTIONAMOUNT" character varying,
"TRANSACTIONDESCRIPTION" character varying,
"TRANSACTIONSTATUS" character varying,
"IMAGEOFRECIEPT" character varying,
"NOOFACCOUNTSPURCHASED" character varying,
"NOOFACCOUNTUSED" character varying,
"PORTALID" integer,
"AMOUNTPAID" character varying,
"REFERENCENUMBER" character varying,
"LOCATION" character varying)
 returns character varying
 language plpgsql
as $function$
    declare
        transaction_id_ varchar;

begin
        insert
	into
	public.whitelabel_transactions(
            admin_id,
	plan_id,
	status,
	request_payload,
	response_payload,
	bank_alfalah_subscription_id,
	promocode_id,
	country,
	currency,
	phone,
	email,
	order_id,
	transaction_reference_number,
	transaction_id,
	transaction_amount,
	transaction_description,
	transaction_status,
	image_url,
	no_of_accounts_purchased,
	no_of_accounts_used,
			portal_id,
			amount_paid,
			reference_number,
			location
        )
values (
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            $7,
            $8,
            $9,
            $10,
            $11,
            $12,
            $13,
            $14,
            $15,
            $16,
            $17,
            $18,
            $19,
            $20,
			$21,
			$22,
			$23,
			$24
        )
        returning id
into
	transaction_id_;
-- Optionally, handle promocode update logic if needed
        if transaction_id_ is not null then
            if $7 is not null then
                update
	public.promo_codes
set
	temp_count = temp_count - 1,
	count = count - 1
where
	id = $7;
end if;
end if;

return transaction_id_;
end;

$function$
;
-- DROP FUNCTION public.add_whitelabel_transaction_alfalah(int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, int4, varchar, varchar);

create or replace
function public.add_whitelabel_transaction_alfalah("ADMINID" integer,
"PLANID" character varying,
"STATUS" character varying,
"REQUESTPAYLOAD" character varying,
"RESPONSEPAYLOAD" character varying,
"BANKALFALAHSUBSCRIPTIONID" character varying,
"PROMOCODE" character varying,
"COUNTRY" character varying,
"CURRENCY" character varying,
"PHONE" character varying,
"EMAIL" character varying,
"ORDERID" character varying,
"TRANSACTIONREFERENCENUMBER" character varying,
"TRANSACTIONID" character varying,
"TRANSACTIONAMOUNT" character varying,
"TRANSACTIONDESCRIPTION" character varying,
"TRANSACTIONSTATUS" character varying,
"IMAGEOFRECIEPT" character varying,
"NOOFACCOUNTSPURCHASED" character varying,
"NOOFACCOUNTUSED" character varying,
"PORTALID" integer,
"AMOUNTPAID" character varying,
"LOCATION" character varying)
 returns character varying
 language plpgsql
as $function$
    declare
        transaction_id_ varchar;

begin
        insert
	into
	public.whitelabel_transactions(
            admin_id,
	plan_id,
	status,
	request_payload,
	response_payload,
	bank_alfalah_subscription_id,
	promocode_id,
	country,
	currency,
	phone,
	email,
	order_id,
	transaction_reference_number,
	transaction_id,
	transaction_amount,
	transaction_description,
	transaction_status,
	image_url,
	no_of_accounts_purchased,
	no_of_accounts_used,
			portal_id,
			amount_paid,
			reference_number,
			location,
	is_approved
        )
values (
            $1,
            $2,
            $3,
            $4,
            $5,
            $6,
            $7,
            $8,
            $9,
            $10,
            $11,
            $12,
            $13,
            $14,
            $15,
            $16,
            $17,
            $18,
            $19,
            $20,
			$21,
			$22,
			public.generate_random_string(24),
			$23,
			true
        )
        returning id
into
	transaction_id_;
-- Optionally, handle promocode update logic if needed
        if transaction_id_ is not null then
            if $7 is not null then
                update
	public.promo_codes
set
	temp_count = temp_count - 1,
	count = count - 1
where
	id = $7;
end if;
end if;

if $17 = 'Paid' then 
			perform public.add_white_label_total_account($21 ,
$2 ,
$19::integer,
transaction_id_);
end if;

return transaction_id_;
end;

$function$
;
-- DROP FUNCTION public.approve_admin_transaction(varchar);

create or replace
function public.approve_admin_transaction("TRANSACTIONID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

data_white_label_transaction public.whitelabel_transactions;

plan_id_ character varying;

begin
		update
	public.whitelabel_transactions
set
	is_approved = true ,
	status = 'completed'
where
	id = $1;

select
	*
into
	data_white_label_transaction
from
	public.whitelabel_transactions
where
	id = $1;

select
	plan_id
into
	plan_id_
from
	public.bridge_paln_subplans bps
where
	bps.plan_id = data_white_label_transaction.plan_id;

perform public.add_white_label_total_account(
    data_white_label_transaction.portal_id, 
    plan_id_,
    data_white_label_transaction.no_of_accounts_purchased::integer, 
    $1
);

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.approve_country(varchar);

create or replace
function public.approve_country("ID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
    update
	public.countries
set
	is_approved = true,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.approve_transaction(varchar);

create or replace
function public.approve_transaction("TRANSACTIONID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

data_transaction public.user_transactions;

begin
		select
	*
into
	data_transaction
from
	public.user_transactions
where
	id = $1;
-- Check if the transaction exists
	    if not found then
	        return false;
end if;

update
	public.user_transactions
set
	is_approved = true ,
	status = 'completed'
where
	id = $1;

update
	public.users
set
	is_subscribed = true,
	subscription_id = data_transaction.subscription_id,
	subscription_time = now()
where
	id = data_transaction.user_id;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.assign_account(int4, varchar, int4, int4, varchar);

create or replace
function public.assign_account("PORTALID" integer,
"PLANID" character varying,
"USERID" integer,
"ADMINID" integer,
"MANUAL" character varying)
 returns boolean
 language plpgsql
as $function$
declare
    rows_updated integer = 0;

white_label_total_accounts_ public.white_label_total_accounts;

branch_id_ character varying;

accounts_count_ int4;

begin
	select
	branch_id
into
	branch_id_
from
	public.admins
where
	id = $4;

select
	*
into
	white_label_total_accounts_
from
	public.white_label_total_accounts
where
	portal_id = $1
	and plan_id = $2;

if (white_label_total_accounts_.total_accounts > 0)
or $1 = 1 then

		if (branch_id_ is null) then
	        update
	public.users
set
	            is_subscribed = true,
	            plan_id = $2,
	            subscription_time = now()
where
	id = $3;

get diagnostics rows_updated = ROW_COUNT;

if rows_updated > 0 then
	            if $1 != 1 then
	                update
	public.white_label_total_accounts
set
	total_accounts = total_accounts - 1
where
	plan_id = $2
	and portal_id = $1;
end if;

perform public.add_in_whitelabel_transactions_account_usage($2,
$3,
$4,
$5);

return true;
end if;

elseif (branch_id_ is not null) then
			select
	branches ->> branch_id_
into
	accounts_count_
from
	public.white_label_total_accounts
where
	portal_id = $1
	and plan_id = $2;

if accounts_count_ > 0 then
		        update
	public.users
set
		            is_subscribed = true,
		            plan_id = $2,
		            subscription_time = now()
where
	id = $3;

get diagnostics rows_updated = ROW_COUNT;

if rows_updated > 0 then
--		            IF $1 != 1 THEN
						update
	public.white_label_total_accounts
set
	branches = jsonb_set(
						    branches,
						    array[branch_id_],
						    (
						        coalesce(
						            (branches ->> branch_id_)::int,
						            0
						        ) - 1
						    )::text::jsonb
						),
						assigned = assigned - 1,
						total_accounts = total_accounts - 1
where
	portal_id = $1
	and plan_id = $2;
--		            END IF;
		
		            perform public.add_in_whitelabel_transactions_account_usage($2,
$3,
$4,
$5);

return true;
end if;
end if;
end if;
end if;

return false;
end;

$function$
;
-- DROP FUNCTION public.assign_revoke_accounts_to_branches(varchar, int4, int4, varchar);

create or replace
function public.assign_revoke_accounts_to_branches("BRANCHID" character varying,
"NOOFACCOUNTS" integer,
"PORTALID" integer,
"PLANID" character varying)
 returns integer
 language plpgsql
as $function$
	declare 
		total_accounts_ int4;

assigned_accounts_ int4;

rows_updated integer = 0;

begin
		if exists (
select
	1
from
	public.branches
where
	portal_id = $3
	and id = $1) then
			select
	total_accounts,
	assigned
into
	total_accounts_,
	assigned_accounts_
from
	public.white_label_total_accounts
where
	portal_id = $3
	and plan_id = $4;

if (assigned_accounts_ + ($2)) < 0 then
			return 4;

elseif (total_accounts_ - assigned_accounts_) >= ($2) then
				update
	public.white_label_total_accounts
set
	branches = jsonb_set(
				    branches,
				    array[$1],
				    (
				        coalesce(
				            (branches ->> $1)::int,
				            0
				        ) + $2
				    )::text::jsonb
				),
				assigned = assigned + ($2)
where
	portal_id = $3
	and plan_id = $4;

get diagnostics rows_updated = ROW_COUNT;

if rows_updated > 0 then
			        return 1;
else
			        return 0;
end if;

elseif (total_accounts_ - assigned_accounts_) < ($2) then
				return 2;
end if;
else 
			return 3;
end if;
end;

$function$
;
-- DROP FUNCTION public.assign_revoke_accounts_to_branches(varchar, int4, int4, varchar, int4);

create or replace
function public.assign_revoke_accounts_to_branches("BRANCHID" character varying,
"NOOFACCOUNTS" integer,
"PORTALID" integer,
"PLANID" character varying,
"ADMINID" integer)
 returns integer
 language plpgsql
as $function$
	declare 
		total_accounts_ int4;

assigned_accounts_ int4;

rows_updated integer = 0;

begin
		if exists (
select
	1
from
	public.branches
where
	portal_id = $3
	and id = $1) then
			select
	total_accounts,
	assigned
into
	total_accounts_,
	assigned_accounts_
from
	public.white_label_total_accounts
where
	portal_id = $3
	and plan_id = $4;

if (assigned_accounts_ + ($2)) < 0 then
			perform public.add_branch_account_transaction($5,
$2::character varying,
'You can not revoke more accounts than assigned',
$1,
$3);

return 4;

elseif (total_accounts_ - assigned_accounts_) >= ($2) then
				update
	public.white_label_total_accounts
set
	branches = jsonb_set(
				    branches,
				    array[$1],
				    (
				        coalesce(
				            (branches ->> $1)::int,
				            0
				        ) + $2
				    )::text::jsonb
				),
				assigned = assigned + ($2)
where
	portal_id = $3
	and plan_id = $4;

get diagnostics rows_updated = ROW_COUNT;

if rows_updated > 0 then
					perform public.add_branch_account_transaction($5,
$2::character varying,
'Accounts assigned/revoked successfully',
$1,
$3);

return 1;
else
					perform public.add_branch_account_transaction($5,
$2::character varying,
'Something went wrong while assigning/revoking accounts',
$1,
$3);

return 0;
end if;

elseif (total_accounts_ - assigned_accounts_) < ($2) then
				perform public.add_branch_account_transaction($5,
$2::character varying,
'No accounts available to assign/revoke',
$1,
$3);

return 2;
end if;
else 
			perform public.add_branch_account_transaction($5,
$2::character varying,
'You can not assign/revoke accounts to this branch',
$1,
$3);

return 3;
end if;
end;

$function$
;
-- DROP FUNCTION public.authenticate_user_with_auth(varchar, varchar, int4, varchar, timestamptz);

create or replace
function public.authenticate_user_with_auth("EMAIL" character varying,
"AUTHID" character varying,
"PORTALID" integer,
"SESSIONID" character varying,
"SESSIONEXPIRY" timestamp with time zone)
 returns table("Status" integer,
"UserId" integer,
"UserName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"EmailVerified" boolean,
"IsDeleted" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying,
"City" character varying,
"ImageUrl" character varying,
"ExamDate" timestamp without time zone,
"EXAMTARGET" text,
"IsSubscribed" boolean,
"SubscriptionID" character varying,
"SubscriptionEndTimeUTC" timestamp with time zone,
"PlanID" character varying,
"PlanName" character varying,
"PortalID" integer)
 language plpgsql
as $function$
declare
    user_info public.users%ROWTYPE;

subscription_end timestamp with time zone;

plan_name_ character varying;

plan_days integer;

begin

    select
	u.id,
	u.name,
	u.email,
	u.created_at,
	u.is_email_verified,
	u.is_deleted,
	u.phone_number,
	u.country_code,
	u.city,
	u.image_url,
	u.exam_date,
	u.exam_target,
	u.is_subscribed,
	u.subscription_id,
	u.subscription_time,
	u.plan_id,
	pfw.plan,
	pfw.days ,
	u.portal_id
    into
	user_info.id,
	user_info.name,
	user_info.email,
	user_info.created_at,
	user_info.is_email_verified,
	user_info.is_deleted,
	user_info.phone_number,
	user_info.country_code,
	user_info.city,
	user_info.image_url,
	user_info.exam_date,
	user_info.exam_target,
	user_info.is_subscribed,
	user_info.subscription_id,
	user_info.subscription_time,
	user_info.plan_id,
	plan_name_,
	plan_days ,
	user_info.portal_id
from
	public.users u
left join public.plans_for_whitelabels pfw on
	u.plan_id = pfw.id
where
	u.email = $1
	and u.is_deleted = false
	and u.portal_id = $3;

if user_info.id is null then
        return QUERY
select
	0,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null;
else
        if user_info.google_id is not null
and user_info.google_id <> $2 then
            return QUERY
select
	2,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null,
	null;
end if;

if not user_info.is_email_verified then
            update
	public.users
set
	is_email_verified = true,
	google_id = $2
where
	id = user_info.id;
end if;

if user_info.google_id is null then
            update
	public.users
set
	google_id = $2
where
	id = user_info.id;
end if;

if user_info.subscription_id is not null then
            select
	((user_info.subscription_time + (s.days || ' days')::interval) at TIME zone 'UTC')::timestamptz
            into
	subscription_end
from
	public.subscriptions s
where
	s.id = user_info.subscription_id;
end if;

update
	public.users
set
	sessionid = $4,
	session_expiry = $5
where
	id = user_info.id;

return QUERY
select
	1,
	user_info.id,
	user_info.name,
	user_info.email,
	user_info.created_at,
	user_info.is_email_verified,
	user_info.is_deleted,
	user_info.phone_number,
	user_info.country_code,
	user_info.city,
	user_info.image_url,
	user_info.exam_date,
	user_info.exam_target,
	user_info.is_subscribed,
	user_info.subscription_id,
	coalesce(subscription_end,
	((user_info.subscription_time + (plan_days || ' days')::interval) at TIME zone 'UTC')::timestamptz),
	user_info.plan_id,
	plan_name_,
	user_info.portal_id;
end if;
end;

$function$
;
-- DROP FUNCTION public.authenticate_user_with_auth(varchar, varchar);

create or replace
function public.authenticate_user_with_auth("EMAIL" character varying,
"AUTHID" character varying)
 returns table("Status" integer,
"UserId" integer,
"UserName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"IsDeleted" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying)
 language plpgsql
as $function$
  declare
	  user_info public.users;

admin_name character varying;

begin
	  select
	*
into
	user_info
from
	public.users
where
	email = $1
	and is_deleted = false;

if user_info is null then
-- User credentials are wrong
		  return QUERY
select
	0 as "Status",
	null::integer as "UserId",
	null::character varying as "UserName",
							   null::character varying as "Email",
	null::timestamp as "CreatedAt",
	null::boolean as "IsDeleted" , 
							   null::character varying as "PhoneNumber" ,
	null::character varying as "CountryCode"
							   ;
else
-- User exists, but email is not verified	
	  	if user_info.google_id is not null
and not user_info.google_id = $2 then
		  return QUERY
select
	2 as "Status",
	null::integer as "UserId",
	null::character varying as "UserName",
							   null::character varying as "Email",
	null::timestamp as "CreatedAt",
	null::boolean as "IsDeleted" , 
							   null::character varying as "PhoneNumber" ,
	null::character varying as "CountryCode"
							   ;
end if;

if not user_info.is_email_verified then
		  	update
	public.users
set
	is_email_verified = true ,
	google_id = $2
where
	id = user_info.id;
end if;

if user_info.google_id is null then
		  	update
	public.users
set
	google_id = $2
where
	id = user_info.id;
end if;

return QUERY
select
	1 as "Status",
	user_info.id as "UserId",
	user_info.name as "UserName",
	user_info.email as "Email",
							   user_info.created_at,
	user_info.is_deleted ,
	user_info.phone_number ,
	user_info.country_code;
end if;
end;

$function$
;
-- DROP FUNCTION public.block_student_by_admin(int4);

create or replace
function public.block_student_by_admin("USERID" integer)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.users
set
	is_deleted = not is_deleted
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.block_subscription_by_admin(varchar);

create or replace
function public.block_subscription_by_admin("SUBSCRIPTIONID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.subscriptions
set
	inactive = not inactive
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.check_admin(int4);

create or replace
function public.check_admin("ADMINID" integer)
 returns boolean
 language plpgsql
as $function$
begin
-- Check if the user exists in public.users table
    if exists (
select
	1
from
	public.admins
where
	id = $1) then
        return true;
else
        return false;
end if;
end;

$function$
;
-- DROP FUNCTION public.check_admin_permission(int4, varchar);

create or replace
function public.check_admin_permission("ADMINID" integer,
"PERMISSIONID" character varying)
 returns boolean
 language plpgsql
as $function$
	begin
-- Check if the user exists in public.users table
    if exists (
select
	1
from
	public.permissions_admin pd
where
	pd.admin_id = $1
	and pd.permission_id = $2) then
        return true;
else
        return false;
end if;
end;

$function$
;
-- DROP FUNCTION public.check_and_subtract_promocode_validity(varchar, int4);

create or replace
function public.check_and_subtract_promocode_validity("PROMOCODEID" character varying,
"USERID" integer)
 returns table("Percentage" integer,
"FixedAmount" integer)
 language plpgsql
as $function$
declare 
	percentage_ integer;

fixedamount_ integer;

begin
    select
	percentage,
	fixed_amount
into
	percentage_,
	fixedamount_
from
	public.promo_codes
where
	id = $1
	and active = true
	and (user_id = $2
		or user_id is null)
	and count - temp_count > 0;

if percentage_ is not null
or fixedamount_ is not null then
		update
	public.promo_codes
set
	temp_count = temp_count + 1
where
	id = $1;
end if;

return query
	select
	percentage_,
	fixedamount_;
end;

$function$
;
-- DROP FUNCTION public.check_user(varchar);

create or replace
function public.check_user("Email" character varying)
 returns boolean
 language plpgsql
as $function$
begin
-- Check if the user exists in public.users table
    if exists (
select
	1
from
	public.users
where
	email = $1) then
        return true;
else
        return false;
end if;
end;

$function$
;
-- DROP FUNCTION public.count_of_promocode_used(varchar);

create or replace
function public.count_of_promocode_used("PROMOCODEID" character varying)
 returns table("Users Usage" integer,
"Portals Usage" integer)
 language plpgsql
as $function$
declare
	users_ integer;

portals_ integer;

begin

    select
	count(*)::integer
into
	users_
from
	public.user_transactions
where
	promocode_id = $1;

select
	count(*)::integer
into
	portals_
from
	public.whitelabel_transactions
where
	promocode_id = $1;

return QUERY
	select
	users_,
	portals_;
end;

$function$
;
-- DROP FUNCTION public.delete_admin(int4);

create or replace
function public.delete_admin("ADMINID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.admins
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_appeared_question(int4, int4);

create or replace
function public.delete_appeared_question("APPEAREDQUESTIONID" integer,
"USERID" integer)
 returns integer
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		if exists (
select
	1
from
	public.appeared_questions aq
where
	aq.id = $1) then 
			if exists (
select
	1
from
	public.appeared_questions aq
where
	aq.id = $1
	and aq.user_id = $2) then
				delete
from
	public.appeared_questions
where
	id = $1;

return 1;
else
				return -1;
end if;
end if;

return 0;
end;

$function$
;
-- DROP FUNCTION public.delete_attempted_question(int4);

create or replace
function public.delete_attempted_question("ATTEMPTED_QUESTION_ID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.attempted_questions
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_attempted_question_like(int4, int4);

create or replace
function public.delete_attempted_question_like("USERID" integer,
"ATTEMPTEDQUESTIONID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.attempted_questions_likes
where
	user_id = $1
	and attempted_question_id = $2;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_attempted_questions_comment(int4);

create or replace
function public.delete_attempted_questions_comment("COMMENTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.attempted_questions_comments
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_attempted_questions_comment_like(int4, int4);

create or replace
function public.delete_attempted_questions_comment_like("USERID" integer,
"ATTEMPTEDQUESTIONCOMMENTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.attempted_questions_comment_likes
where
	user_id = $1
	and attempted_questions_comment_id = $2;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_bookmark(int4);

create or replace
function public.delete_bookmark("BOOKMARKID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.bookmarks
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_branch(varchar);

create or replace
function public.delete_branch("BRANCH_ID" character varying)
 returns void
 language plpgsql
as $function$
declare
    branch_count integer;

portal_id_ integer;

begin

    select
	coalesce((branches ->> $1)::int,
	0),
	portal_id
    into
	branch_count,
	portal_id_
from
	public.white_label_total_accounts
where
	branches ? $1;

update
	public.white_label_total_accounts
set
	branches = branches - $1,
	assigned = assigned - branch_count
where
	portal_id = portal_id_;

update
	public.users
set
	branch_id = null
where
	branch_id = $1;

update
	public.admins
set
	branch_id = null
where
	branch_id = $1;

delete
from
	public.branches
where
	id = $1;
end;

$function$
;
-- DROP FUNCTION public.delete_comment(int4);

create or replace
function public.delete_comment("COMMENTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.comments
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_comment_like(int4, int4);

create or replace
function public.delete_comment_like("USERID" integer,
"COMMENTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.comment_likes
where
	user_id = $1
	and comment_id = $2;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_country(varchar);

create or replace
function public.delete_country("COUNTRYID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
	delete
from
		public.countries
where
		id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_help_center(varchar);

create or replace
function public.delete_help_center("ID" character varying)
 returns boolean
 language plpgsql
as $function$
declare
    row_deleted integer := 0;

begin
    delete
from
	public.help_center
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_mock_attempted_development(int4);

create or replace
function public.delete_mock_attempted_development("USERID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.mock_attempted_questions
where
	user_id = $1;

delete
from
	public.mock_test_attempts
where
	user_id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_mock_test(int4);

create or replace
function public.delete_mock_test("MOCKTESTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.mock_test
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_mock_test_attempt(int4);

create or replace
function public.delete_mock_test_attempt("MOCKTESTATTEMPTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted1 integer := 0;

row_deleted2 integer := 0;

begin
		delete
from
	public.mock_attempted_questions
where
	mock_test_attempt_id = $1;

get diagnostics row_deleted1 = ROW_COUNT;
--    	if( row_deleted1 > 0) then
			delete
from
	public.mock_test_attempts
where
	id = $1;

get diagnostics row_deleted2 = ROW_COUNT;

return row_deleted2 > 0;
--    	end if;		
--    	return false;
end;

$function$
;
-- DROP FUNCTION public.delete_mock_test_questions_by_test_id(int4);

create or replace
function public.delete_mock_test_questions_by_test_id("MOCKTESTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.mock_test_questions
where
	mock_test_id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_option(int4);

create or replace
function public.delete_option("OPTIONID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.options
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_portal(int4);

create or replace
function public.delete_portal("PORTALID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.portal
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_prediction_file(int4);

create or replace
function public.delete_prediction_file("FILEID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.prediction_file
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_question(int4);

create or replace
function public.delete_question("QUESTIONID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.question
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_strategy_video(int4);

create or replace
function public.delete_strategy_video("VIDEOID" integer)
 returns boolean
 language plpgsql
as $function$
declare
	row_deleted integer := 0;

begin
	delete
from
	public.strategy_video
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_subscription(varchar);

create or replace
function public.delete_subscription("SUBSCRIPTION_ID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare
		row_deleted integer := 0;

begin
		delete
from
	public.subscriptions
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_template_grammar_pdf(int4);

create or replace
function public.delete_template_grammar_pdf("TEMPLATEID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.templates_and_grammar_pdfs
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_test(int4);

create or replace
function public.delete_test("TESTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.test
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_test_category(int4);

create or replace
function public.delete_test_category("TESTCATEGORYID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.test_categories
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_test_question_note_of_user(int4);

create or replace
function public.delete_test_question_note_of_user("NOTEID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.test_question_notes
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_test_questions_by_test_id(int4);

create or replace
function public.delete_test_questions_by_test_id("TESTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.test_questions
where
	test_id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_user(int4, bool);

create or replace
function public.delete_user("USERID" integer,
"ISDELETED" boolean)
 returns boolean
 language plpgsql
as $function$
	declare 
		  rows_updated integer = 0;

begin
		  update
	public.users
set 
			is_deleted = $2
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_user_permanently(int4);

create or replace
function public.delete_user_permanently("USERID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.users
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_user_transaction(varchar);

create or replace
function public.delete_user_transaction("TRANSACTION_ID" character varying)
 returns boolean
 language plpgsql
as $function$
    declare
        row_deleted integer := 0;

begin
        delete
from
	public.user_transactions
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.delete_vocab(int4);

create or replace
function public.delete_vocab("VOCABID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.vocab_bank
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.free_subscription_success(int4, varchar, varchar, varchar, varchar, varchar, varchar, bool, varchar, varchar, varchar, varchar, int4, varchar, varchar);

create or replace
function public.free_subscription_success("USERID" integer,
"SUBSCRIPTION_ID" character varying,
"STATUS" character varying,
"REQUESTPAYLOAD" character varying,
"RESPONSEPAYLOAD" character varying,
"BANKALFALAHSUBSCRIPTIONID" character varying,
"PROMOCODE" character varying,
"ISAPPROVED" boolean,
"COUNTRY" character varying,
"CURRENCY" character varying,
"PHONE" character varying,
"EMAIL" character varying,
"PORTALID" integer,
"REFERENCENUMBER" character varying,
"LOCATION" character varying)
 returns character varying
 language plpgsql
as $function$
declare
    transaction_id_ character varying;

promo_percentage int4;

begin
-- Check if the promo code exists and has 100% discount
    select
	percentage 
    into
	promo_percentage
from
	public.promo_codes
where
	id = $7
	and active = true
	and expiry_date > now();
-- Ensure the promo code is not expired

    if promo_percentage is null
or promo_percentage != 100 then
        return null;
-- Promo code is invalid or not 100%
end if;
-- Insert into user_transactions
    insert
	into
	public.user_transactions(
        user_id,
	subscription_id,
	status,
	request_payload,
	response_payload,
	bank_alfalah_subscription_id,
	promocode_id,
	is_approved,
	country,
	currency,
	phone,
	email,
	portal_id,
	reference_number,
	location
    )
values (
        $1,
$2,
$3,
$4,
$5,
$6,
$7,
$8,
$9,
$10,
$11,
$12,
$13,
$14,
$15
    )
    returning id
    into
	transaction_id_;
-- If the transaction is successfully created, update promo_codes temp_count
    if transaction_id_ is not null then
        update
	public.promo_codes
set
	temp_count = temp_count + 1
where
	id = $7;

perform public.approve_transaction(transaction_id_);
end if;

return transaction_id_;
end;

$function$
;
-- DROP FUNCTION public.get_admin_transactions(int4);

create or replace
function public.get_admin_transactions("ADMINID" integer)
 returns setof whitelabel_transactions
 language plpgsql
as $function$
    begin
        return QUERY
        select
	*
from
	public.whitelabel_transactions
where
	admin_id = $1
order by
	created_at
		;
end;

$function$
;
-- DROP FUNCTION public.get_all_admins();

create or replace
function public.get_all_admins()
 returns table("Id" integer,
"Email" character varying,
"Name" character varying,
"Role" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"PortalId" integer,
"BranchId" character varying,
"PortalLink" character varying,
"BranchName" character varying,
"AdminPermissions" character varying[])
 language plpgsql
as $function$
begin
    return QUERY
    select
	a.id,
	a.email,
	a."name",
	a.role,
	a.created_at,
	a.updated_at,
	a.portal_id,
	a.branch_id,
	p.portal_link,
	b.name,
	ARRAY_AGG(pa.permission_id) as "AdminPermissions"
	-- Aggregate permissions into an array
from
	public.admins a
left join public.branches b
        on
	a.branch_id = b.id
left join public.portal p
        on
	a.portal_id = p.id
left join public.permissions_admin pa
        on
	a.id = pa.admin_id
	-- Join with the permissions_admin table to get permissions
group by
	a.id,
	a.email,
	a."name",
	a.role,
	a.created_at,
	a.updated_at,
	a.portal_id,
	a.branch_id,
	p.portal_link,
	b.name;
end;

$function$
;
-- DROP FUNCTION public.get_all_approved_countries();

create or replace
function public.get_all_approved_countries()
 returns table("Id" character varying,
"Name" character varying,
"Currency" character varying)
 language plpgsql
as $function$
	begin
		return query
		select
		id ,
		"name" ,
		currency
from
		public.countries
where
	is_approved = true;
end;

$function$
;
-- DROP FUNCTION public.get_all_branches();

create or replace
function public.get_all_branches()
 returns table("Id" character varying,
"Name" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"PortalId" integer)
 language plpgsql
as $function$
begin
    return QUERY
    select
	id,
	"name",
	created_at,
	updated_at,
	portal_id
from
	public.branches;
end;

$function$
;
-- DROP FUNCTION public.get_all_categorized_tests();

create or replace
function public.get_all_categorized_tests()
 returns table("Categories" json)
 language plpgsql
as $function$
	begin
		return query
		select
	json_agg(item) as categories
from
	(
	select
		t.category_id,
		tc.category_name, 
		         array_agg(json_build_object('subcategory_id',
		t.id,
		'subcategory_name',
		t.test_name)) as subcategories
	from
		test t
	left join public.test_categories tc 
		  on
		t.category_id = tc.id
	group by
		t.category_id ,
		tc.category_name
		) item;
end;

$function$
;
-- DROP FUNCTION public.get_all_countries();

create or replace
function public.get_all_countries()
 returns table("Id" character varying,
"Name" character varying,
"Currency" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"IsApproved" boolean)
 language plpgsql
as $function$
	begin
		return query
		select
		id ,
		"name" ,
		currency,
		created_at ,
		updated_at ,
		is_approved
from
		public.countries;
end;

$function$
;
-- DROP FUNCTION public.get_all_help_centers();

create or replace
function public.get_all_help_centers()
 returns table("Id" character varying,
"Name" character varying,
"Link" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
begin
    return QUERY
    select
	id,
	"name",
	link,
	created_at,
	updated_at
from
	public.help_center;
end;

$function$
;
-- DROP FUNCTION public.get_all_mock_tests(int4);

create or replace
function public.get_all_mock_tests("MOCKTESTTYPEID" integer)
 returns table("MockTestId" integer,
"MockTestName" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"TotalTime" integer,
"TotalQuestions" integer,
"ISPTECORE" boolean,
"IndividualTimes" text)
 language plpgsql
as $function$
 begin
        return query
        select
	mt.id,
	mt.name,
	mt.created_at,
	mt.updated_at,
	mt.total_time,
	coalesce((
	select
		count(*)
	from
		public.mock_test_questions mtq
	where
		mtq.mock_test_id = mt.id))::integer as TotalQuestions,
	mt.core,
	mt.individual_times
from
	public.mock_test mt
where
	case
		when $1 is null then mt.mock_test_type_id is null
		else mt.mock_test_type_id = $1
	end
order by
	mt.order_id desc
        ;
end;

$function$
;
-- DROP FUNCTION public.get_all_mock_tests_for_user(int4, bool, int4);

create or replace
function public.get_all_mock_tests_for_user("USERID" integer,
"ISPTECORE" boolean,
"MOCKTESTID" integer)
 returns table("MockTestId" integer,
"MockTestName" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"TotalTime" integer,
"TotalQuestions" integer,
"ResumeTestId" integer,
"IndividualTimes" text)
 language plpgsql
as $function$
begin
    return QUERY
    select
	mt.id as "MockTestId",
	mt.name as "MockTestName",
	mt.created_at as "CreatedAt",
	mt.updated_at as "UpdatedAt",
	mt.total_time as "TotalTime",
	coalesce((
	select
		COUNT(*)
	from
		public.mock_test_questions mtq
	where
		mtq.mock_test_id = mt.id
        ),
	0)::int4 as "TotalQuestions",
	(
	select
		mta.id
	from
		mock_test_attempts mta
	where
		mt.id = mta.mock_test_id
		and mta.user_id = $1
		and mta.status = 'pending'
	limit 1
        ) as "ResumeTestId",
	mt.individual_times as "IndividualTimes"
	-- Adding the individual_times column
from
	public.mock_test mt
where
	mt.core = $2
	and (
            case
		when $3 is null then mt.mock_test_type_id is null
		else mt.mock_test_type_id = $3
	end
        )
order by
	mt.id asc;
end;

$function$
;
-- DROP FUNCTION public.get_all_options();

create or replace
function public.get_all_options()
 returns table("OptionId" integer,
"OptionNames" character varying,
"AnswerNames" character varying,
"QuestionId" integer,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
	begin
		return query
		select 
		id,
		option_names,
		answer_names,
		question_id,
		created_at,
		updated_at
from
	public.options;
end;

$function$
;
-- DROP FUNCTION public.get_all_permissions();

create or replace
function public.get_all_permissions()
 returns jsonb
 language plpgsql
as $function$
	begin
		return (
select
	json_agg(main_type_obj
order by
	main_type_obj.main_type_id) as result
from
	(
	select
		pm.id as main_type_id,
		pm.main_type_name,
		json_object_agg(ps.sub_type_name,
		sub_type_permissions
	order by
		ps.id) as sub_types
	from
		(
		select
			p.main_type,
			p.sub_type,
			json_agg(json_build_object(
                   'id',
			p.id,
			'name',
			p.name,
			'created_at',
			p.created_at
               )
		order by
			p.id) as sub_type_permissions
		from
			public.permissions p
		group by
			p.main_type,
			p.sub_type
    ) as grouped_permissions
	join public.permission_main_type pm on
		grouped_permissions.main_type = pm.id
	join public.permission_sub_types ps on
		grouped_permissions.sub_type = ps.id
	group by
		pm.id,
		pm.main_type_name
) as main_type_obj
);
end;

$function$
;
-- DROP FUNCTION public.get_all_plans_of_country(varchar);

create or replace
function public.get_all_plans_of_country("ID" character varying)
 returns table("PlanForWhiteLabel" character varying,
"PlanDays" character varying,
"NoOfAccounts" character varying,
"BridgePlanSubplanId" character varying,
"PricePerAccount" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
begin
   return query
   select
	pfw.name,
	pfw.plan,
	sfw.name,
	bps.id,
	bps.price_per_account,
	bps.created_at,
	bps.updated_at
from
	public.plans_for_whitelabels pfw
left join public.bridge_paln_subplans bps
   on
	pfw.id = bps.plan_id
left join public.subplans_for_whitelabels sfw
   on
	bps.subplan_id = sfw.id
where
	pfw.country_id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_all_portal_admins(int4, varchar);

create or replace
function public.get_all_portal_admins("PORTALID" integer,
"BRANCHNAME" character varying)
 returns table("Id" integer,
"Email" character varying,
"Name" character varying,
"Role" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"BranchID" character varying,
"BranchName" character varying,
"AdminPermissions" character varying[])
 language plpgsql
as $function$
begin
    return query
    select
	a.id,
	a.email,
	a."name",
	a.role,
	a.created_at,
	a.updated_at,
	b.id,
	b.name,
	array_agg(pa.permission_id) as "AdminPermissions"
	-- Aggregate permissions into an array
from
	public.admins a
left join public.branches b
        on
	a.branch_id = b.id
left join public.permissions_admin pa
        on
	a.id = pa.admin_id
	-- Join with the permissions_admin table to get permissions
where
	a.portal_id = $1
	and (b.name ilike $2
		or $2 is null)
group by
	a.id,
	a.email,
	a."name",
	a.role,
	a.created_at,
	a.updated_at,
	b.id,
	b.name;
end;

$function$
;
-- DROP FUNCTION public.get_all_portals();

create or replace
function public.get_all_portals()
 returns table("PortalId" integer,
"PortalLink" character varying,
"PortalOwnerName" character varying,
"Location" character varying,
"CreatedAt" timestamp without time zone,
"CountryName" character varying)
 language plpgsql
as $function$
	begin
		return query
		select 
			p.id,
			p.portal_link,
			p.portal_owner_name,
			p.location,
			p.created_at,
	c.name
from
	public.portal p
left join public.countries c
            on
	p.country_id = c.id
;
end;

$function$
;
-- DROP FUNCTION public.get_all_prediction_files(bool);

create or replace
function public.get_all_prediction_files("CORE" boolean)
 returns table("FileId" integer,
"Name" character varying,
"FileUrl" character varying,
"Priority" integer,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
	begin
		return query
		select
	id,
	name,
	file_url,
	priority,
	created_at,
	updated_at
from
	public.prediction_file
where
	core = $1;
end;

$function$
;
-- DROP FUNCTION public.get_all_promo_codes();

create or replace
function public.get_all_promo_codes()
 returns table("Id" character varying,
"Percentage" integer,
"Created_at" timestamp without time zone,
"Updated_at" timestamp without time zone,
"Active" boolean,
"User_id" integer,
"Fixed_amount" integer,
"Portal_id" integer,
"Count" integer,
"Temp_count" integer,
"Expiry_date" timestamp without time zone,
"Expired" boolean)
 language plpgsql
as $function$
begin
    return QUERY
    select
	id,
	percentage,
	created_at,
	updated_at,
	active,
	user_id,
	fixed_amount,
	portal_id,
	count,
	temp_count,
	expiry_date,
	case
		when expiry_date < NOW() then true
		else false
	end as "expired"
from
	public.promo_codes
order by
	created_at;
end;

$function$
;
-- DROP FUNCTION public.get_all_questions(int4, int4);

create or replace
function public.get_all_questions("PAGE" integer,
"PAGESIZE" integer)
 returns table("QuestionId" integer,
"NAME" character varying,
"Statement" character varying,
"AudioObject" character varying,
"TotalMarks" integer,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"MajorAspects" character varying,
"MinorAspects" character varying,
"OptionId" integer,
"OptionNames" character varying,
"AnswerNames" character varying,
"OptionCreatedAt" timestamp without time zone,
"OptionUpdatedAt" timestamp without time zone,
"Category" character varying,
"SubCategory" character varying,
"Prediction" boolean)
 language plpgsql
as $function$
	begin
		return query
		select
	q.id,
	q."name",
	q."statement",
	q.audio_object ,
	q.total_marks,
	q.created_at,
	q.updated_at,
	q.major_aspects,
	q.minor_aspects,
		o.id,
		o.option_names,
		o.answer_names,
		o.created_at,
		o.updated_at,
		tc.category_name,
		t.test_name,
		q.prediction
from
	public.question q
left join public.options o
		on
	o.question_id = q.id
left join public.test t
		on
	q.test_id = t.id
left join public.test_categories tc
		on
	t.category_id = tc.id
order by
	q.created_at
limit $1 offset $2
		;
end;

$function$
;
-- DROP FUNCTION public.get_all_strategy_videos(bool);

create or replace
function public.get_all_strategy_videos("CORE" boolean)
 returns table("Id" integer,
"Title" character varying,
"Author" character varying,
"YtLink" character varying,
"Category" character varying,
"Priority" integer,
"Language" character varying,
"Core" boolean,
"Thumbnail" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
begin
	return QUERY
	select
		id,
		title,
		author,
		yt_link,
		category,
		priority,
		"language",
		core,
		thumbnail,
		created_at,
		updated_at
from
		public.strategy_video
where
	core = $1;
end;

$function$
;
-- DROP FUNCTION public.get_all_students_by_super_admin(int4, varchar, bool, varchar);

create or replace
function public.get_all_students_by_super_admin("PORTALID" integer,
"NAME" character varying,
"SUBSCRIBED" boolean,
"TYPE" character varying)
 returns table("Id" integer,
"Email" character varying,
"Name" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"Type" character varying,
"IsSubscribed" boolean)
 language plpgsql
as $function$
	begin
		return query
		select
	id,
	email,
	"name",
	created_at,
	updated_at,
	type,
	is_subscribed
from
	public.users
where
	portal_id = $1
	and ("name" ilike $2
		or $2 is null)
	and (is_subscribed = $3
		or $3 is null)
	and (type ilike $4
		or $4 is null);
end;

$function$
;
-- DROP FUNCTION public.get_all_subscriptions();

create or replace
function public.get_all_subscriptions()
 returns table("Id" character varying,
"Name" character varying,
"Description" character varying,
"PricePKR" integer,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"InActive" boolean,
"Days" integer,
"Discount" character varying)
 language plpgsql
as $function$
	begin
		return query
		select
	id,
	"name",
	"desc",
	price_pkr,
	created_at,
	updated_at ,
	inactive,
	days,
	discount
from
	public.subscriptions
order by
	days asc;
end;

$function$
;
-- DROP FUNCTION public.get_all_templates(bool);

create or replace
function public.get_all_templates("ISTEMPLATE" boolean)
 returns table("TemplateId" integer,
"Name" character varying,
"PdfUrl" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
	begin
		return query
		select
	id,
	name,
	pdf_url,
	created_at,
	updated_at
from
	public.templates_and_grammar_pdfs
where
	is_template = $1;
end;

$function$
;
-- DROP FUNCTION public.get_all_templates_of_portal(bool, int4);

create or replace
function public.get_all_templates_of_portal("ISTEMPLATE" boolean,
"PORTALID" integer)
 returns table("TemplateId" integer,
"Name" character varying,
"PdfUrl" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
declare
	template_visible_ boolean;

grammar_visible_ boolean;

begin
	select 
		template_visible,
		grammar_visible
	into 
		template_visible_,
		grammar_visible_
from
	public.portal
where
	id = $2;

return query
		select
	id,
	name,
	pdf_url,
	created_at,
	updated_at
from
	public.templates_and_grammar_pdfs
where 
			is_template = $1
	and (
				portal_id = $2
		or (template_visible_
			and portal_id = 1)
		or (grammar_visible_
			and portal_id = 1)
			);
end;

$function$
;
-- DROP FUNCTION public.get_all_test_categories();

create or replace
function public.get_all_test_categories()
 returns table("TestCategoryId" integer,
"CategoryName" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
	begin
		return query
		select
	id,
	category_name,
	created_at,
	updated_at
from
	public.test_categories
order by
	order_id;
end;

$function$
;
-- DROP FUNCTION public.get_all_tests();

create or replace
function public.get_all_tests()
 returns table("TestId" integer,
"CategoryId" integer,
"TestName" character varying,
"IsAnswerFixed" boolean,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"BeginningTime" integer,
"TotalTime" integer,
"CategoryName" character varying)
 language plpgsql
as $function$
	begin
		return query
		select
	t.id,
	t.category_id,
	t.test_name,
	t.is_answer_fixed,
	t.created_at,
	t.updated_at,
	t.beginning_time,
	t.total_time ,
	tc.category_name
from
	public.test t
left join public.test_categories tc
		on
	t.category_id = tc.id
		;
end;

$function$
;
-- DROP FUNCTION public.get_all_user_transactions(int4, int4, bool, varchar, int4);

create or replace
function public.get_all_user_transactions("PAGESIZE" integer,
"OFFSET" integer,
"ISAPPROVED" boolean,
"REFERENCENUMBER" character varying,
"PORTALID" integer)
 returns table("TransactionId" character varying,
"UserId" integer,
"SubscriptionId" character varying,
"Status" character varying,
"RequestPayload" character varying,
"ResponsePayload" character varying,
"BankAlfalahSubscriptionId" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"PromocodeId" character varying,
"TransactionImageUrl" character varying,
"IsApproved" boolean,
"Country" character varying,
"Currency" character varying,
"Phone" character varying,
"Email" character varying,
"TransactionPortalId" integer,
"PortalName" character varying,
"Username" character varying,
"ReferenceNumber" character varying,
"TranactionAmount" character varying,
"SubscriptionName" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    select
	ut.id as transaction_id,
	ut.user_id,
	ut.subscription_id,
	ut.status,
	ut.request_payload,
	ut.response_payload,
	ut.bank_alfalah_subscription_id,
	ut.created_at,
	ut.updated_at,
	ut.promocode_id,
	ut.image_url as transaction_image_url,
	ut.is_approved,
	ut.country,
	ut.currency,
	ut.phone,
	ut.email,
	ut.portal_id as transaction_portal_id,
	p.portal_owner_name as portal_name,
	u.name as username,
	ut.reference_number,
	ut.transaction_amount,
	s."name"
from
	public.user_transactions ut
inner join 
    public.users u on
	ut.user_id = u.id
left join 
    public.portal p on
	u.portal_id = p.id
left join 
    public.subscriptions s on
	ut.subscription_id = s.id
where
	(p.id = $5
		or $5 is null)
	and
	ut.is_approved = $3
	and (ut.reference_number ilike $4
		or $4 is null)
order by
	ut.created_at desc
limit $1 offset $2;
end;

$function$
;
-- DROP FUNCTION public.get_all_users();

create or replace
function public.get_all_users()
 returns table("Id" integer,
"Email" character varying,
"Name" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"IsEmailVerified" boolean,
"IsDeleted" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying)
 language plpgsql
as $function$
	begin
		return query
		select
	id ,
	email ,
	"name" ,
	created_at ,
	updated_at ,
	is_email_verified,
	is_deleted ,
	phone_number,
	country_code
from
	public.users;
end;

$function$
;
-- DROP FUNCTION public.get_all_vocabs(int4);

create or replace
function public.get_all_vocabs("USERID" integer)
 returns table("Id" integer,
"Name" character varying,
"Type" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"Description" character varying)
 language plpgsql
as $function$
	begin
		return query
		select
	id ,
	"name" ,
	type,
	created_at ,
	updated_at ,
	description
from
	public.vocab_bank
where
	user_id = $1
order by
	created_at desc
		;
end;

$function$
;
-- DROP FUNCTION public.get_all_white_label_total_accounts(int4, int4);

create or replace
function public.get_all_white_label_total_accounts("PORTALID" integer,
"ADMINID" integer)
 returns table("Plan" character varying,
"Details" json)
 language plpgsql
as $function$
begin
    return QUERY
    select
	p."name" as "Plan",
	json_agg(
            json_build_object(
                'PlanID',
	p.id,
	'Plan',
	p.plan,
	'AccountsRemaining',
	coalesce(w.total_accounts,
	0),
	'LastWhiteLabelTransactionId',
	w.last_white_label_transaction_id,
	'AccountsInBranch',
	coalesce(
                    (case
		when a.branch_id is not null then 
                            (
		select
			value::int
		from
			jsonb_each_text(w.branches)
		where
			key = a.branch_id::text)
		when w.total_accounts is not null then 
                            w.total_accounts - w.assigned
		else 
                            0
	end),
	0
                )
	-- Fetch AccountsInBranch with fallback logic
            )
        ) as "Details"
from
	public.plans_for_whitelabels p
left join public.white_label_total_accounts w 
        on
	p.id = w.plan_id
	and w.portal_id = $1
left join public.admins a 
        on
	a.portal_id = w.portal_id
	and a.id = $2
group by
	p."name";
end;

$function$
;
-- DROP FUNCTION public.get_all_whitelabel_transactions(int4, int4, bool, varchar, int4);

create or replace
function public.get_all_whitelabel_transactions("PAGESIZE" integer,
"OFFSET" integer,
"ISAPPROVED" boolean,
"REFERENCENUMBER" character varying,
"PORTALID" integer)
 returns table("TransactionId" character varying,
"AdminId" integer,
"PortalId" integer,
"PlanId" character varying,
"Status" character varying,
"RequestPayload" character varying,
"ResponsePayload" character varying,
"BankAlfalahSubscriptionId" character varying,
"PromocodeId" character varying,
"Country" character varying,
"Currency" character varying,
"Phone" character varying,
"Email" character varying,
"OrderId" character varying,
"TransactionReferenceNumber" character varying,
"TransactionIdOriginal" character varying,
"TransactionAmount" character varying,
"TransactionDescription" character varying,
"TransactionStatus" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"ImageUrl" character varying,
"IsApproved" boolean,
"NoOfAccountsPurchased" character varying,
"NoOfAccountsUsed" character varying,
"PortalName" character varying,
"AdminName" character varying,
"ReferenceNumber" character varying,
"PlanName" character varying,
"Manual" character varying,
"BoughtBuyAndReason" text)
 language plpgsql
as $function$
begin
    return QUERY
    select
	wt.id as "TransactionId",
	wt.admin_id as "AdminId",
	wt.portal_id as "PortalId",
	wt.plan_id as "PlanId",
	wt.status as "Status",
	wt.request_payload as "RequestPayload",
	wt.response_payload as "ResponsePayload",
	wt.bank_alfalah_subscription_id as "BankAlfalahSubscriptionId",
	wt.promocode_id as "PromocodeId",
	wt.country as "Country",
	wt.currency as "Currency",
	wt.phone as "Phone",
	wt.email as "Email",
	wt.order_id as "OrderId",
	wt.transaction_reference_number as "TransactionReferenceNumber",
	wt.transaction_id as "TransactionIdOriginal",
	wt.amount_paid as "TransactionAmount",
	wt.transaction_description as "TransactionDescription",
	wt.transaction_status as "TransactionStatus",
	wt.created_at as "CreatedAt",
	wt.updated_at as "UpdatedAt",
	wt.image_url as "ImageUrl",
	wt.is_approved as "IsApproved",
	wt.no_of_accounts_purchased as "NoOfAccountsPurchased",
	wt.no_of_accounts_used as "NoOfAccountsUsed",
	p.portal_owner_name as "PortalName",
	a.name as "AdminName",
	wt.reference_number,
	pfw."plan",
	wt.manual,
	wt.bought_by_and_reason
from
	public.whitelabel_transactions wt
inner join 
    public.admins a on
	wt.admin_id = a.id
left join 
    public.portal p on
	wt.portal_id = p.id
left join 
    public.plans_for_whitelabels pfw on
	wt.plan_id = pfw.id
where
	(p.id = $5
		or $5 is null)
	and
	wt.is_approved = $3
	and (wt.reference_number ilike $4
		or $4 is null)
order by
	wt.created_at
limit $1 offset $2;
end;

$function$
;
-- DROP FUNCTION public.get_analytics_of_mock_test(int4);

create or replace
function public.get_analytics_of_mock_test("MOCKTESTATTEMPTID" integer)
 returns table("Analytics" character varying)
 language plpgsql
as $function$
	begin
		return query
		select
	total_marks_obtained
from
	public.mock_test_attempts
where
	id = $1
order by
	created_at
		;
end;

$function$
;
-- DROP FUNCTION public.get_appeared_question(int4, int4);

create or replace
function public.get_appeared_question("QUESTIONID" integer,
"USERID" integer)
 returns table("AppearedQuestionId" integer,
"Count" integer,
"ExamDate" timestamp without time zone,
"ExamVenue" character varying,
"ExamMemory" character varying,
"CreatedAt" timestamp without time zone)
 language plpgsql
as $function$
	declare 
		count_appeared_question integer;

begin
		select
	count(*)
into
	count_appeared_question
from
	public.appeared_questions aq
where
	aq.question_id = $1;

return query
		select
			aq.id,
			count_appeared_question,
			aq.exam_date,
			aq.exam_venue,
			aq.exam_memory,
			aq.created_at
from
	public.appeared_questions aq
where
	aq.question_id = $1
	and aq.user_id = $2
order by
	aq.created_at desc;
end;

$function$
;
-- DROP FUNCTION public.get_attempted_mock_tests(int4);

create or replace
function public.get_attempted_mock_tests("USERID" integer)
 returns table("MockTestAttemptId" integer,
"MockTestName" character varying,
"DateTaken" timestamp without time zone,
"TestType" character varying)
 language plpgsql
as $function$
begin
  return QUERY
  select
	mta.id as "MockTestAttemptId",
	mt.name as "MockTestName",
	mta.updated_at as "DateTaken",
	coalesce(mtt.name,
	'Full') as "TestType"
from
	public.mock_test_attempts mta
left join 
    public.mock_test mt on
	mta.mock_test_id = mt.id
left join 
    public.mock_test_types mtt on
	mt.mock_test_type_id = mtt.id
where
	mta.user_id = $1
	and mta.status = 'completed';
end;

$function$
;
-- DROP FUNCTION public.get_attempted_question(int4);

create or replace
function public.get_attempted_question("TESTQUESTIONID" integer)
 returns table(marks_obtained real,
users_response character varying,
time_taken integer,
is_ptecore boolean)
 language plpgsql
as $function$
	begin
		return query
		select 
			marks_obtained,
			users_response,
			time_taken,
			is_ptecore
from
	public.attempted_questions
where
	id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_attempted_questions_by_question_id(int4, int4, int4, int4, bool);

create or replace
function public.get_attempted_questions_by_question_id("QUESTIONID" integer,
"USERID" integer,
"LIMIT" integer,
"OFFSET" integer,
"ISPTECORE" boolean)
 returns table("AttemptedAnswers" jsonb[],
"OptionNames" character varying,
"AnswerNames" character varying)
 language plpgsql
as $function$
	declare
		result_array JSONB[];

related_data JSONB[];

option_names_var character varying;

answer_names_var character varying;

begin
		
	select
	array(
	select
		jsonb_build_object(
    'AttemptedQuestionId',
		aq.id ,
		'MarksObtained',
		aq.marks_obtained,
		'UsersResponse',
		aq.users_response,
		'TimeTaken',
		aq.time_taken,
		'CreatedAt',
		aq.created_at ,
		'UserName' ,
		u.name,
		'UserId' ,
		u.id ,
		'UserImage' ,
		u.image_url,
		'IsLiked',
		exists (
		select
			1
		from
			public.attempted_questions_likes aqlinner
		where
			aqlinner.attempted_question_id = aq.id
			and aqlinner.user_id = $2),
		'TotalLikes',
		(
		select
			count(aqllikes.id)
		from
			public.attempted_questions_likes aqllikes
		where
			aqllikes.attempted_question_id = aq.id
	))
	from
		public.test_questions tq
	right join public.attempted_questions aq on
		tq.id = aq.test_question_id
	inner join public.users u
    on
		aq.user_id = u.id
	where
		tq.id = $1
		and aq.user_id = $2
		and aq.is_ptecore = $5
	order by
		aq.created_at desc
	limit $3 offset $4
	)
into
	result_array ;
--		return query
--		select result_array, option_names , answer_names  from "options"
--		where question_id in (select question_id from public.test_questions where id = $1); 
if array_length(result_array,
1) > 0 then
    for i in array_lower(result_array, 1)..array_upper(result_array, 1) loop
        select
	array(
	select
		jsonb_build_object(
            'CommentId',
		aqc.id,
			'UserId',
		aqc.user_id,
			'CreatedAt',
		(aqc.craeted_at at TIME zone 'UTC',
		'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
			'UserName' ,
		uu.name,
		    'UserImage' ,
		uu.image_url,
			'Comment',
		aqc.attempted_questions_comment,
			'IsLiked',
		exists (
		select
			1
		from
			public.attempted_questions_comment_likes aqclinner
		where
			aqclinner.attempted_questions_comment_id = aqc.id
			and aqclinner.user_id = $2),
			'TotalLikes',
		(
		select
			count(aqcllikes.id)
		from
			public.attempted_questions_comment_likes aqcllikes
		where
			aqcllikes.attempted_questions_comment_id = aqc.id)
			)
	from
		attempted_questions_comments aqc
	left join public.attempted_questions_comment_likes aqcl
            on
		aqc.id = aqcl.attempted_questions_comment_id
	left join public.users uu
            on
		aqc.user_id = uu.id
	where
		aqc.attempted_question_id = (result_array[i] ->> 'AttemptedQuestionId')::int
        )
into
	related_data;

result_array[i] := jsonb_set(result_array[i],
'{Comments}',
to_jsonb(related_data));
end loop;
end if;

if exists(
select
	1
from
	"options"
where
	question_id in (
	select
		question_id
	from
		public.test_questions
	where
		id = $1)) then
			select
	option_names ,
	answer_names
into
	option_names_var,
	answer_names_var
from
	"options"
where
	question_id in (
	select
		question_id
	from
		public.test_questions
	where
		id = $1);
else
			option_names_var := null;

answer_names_var := null;
end if;

return QUERY
select
	result_array,
	option_names_var,
	answer_names_var;
end;

$function$
;
-- DROP FUNCTION public.get_attempted_questions_of_others_by_question_id(int4, int4, int4, int4, bool);

create or replace
function public.get_attempted_questions_of_others_by_question_id("QUESTIONID" integer,
"USERID" integer,
"LIMIT" integer,
"OFFSET" integer,
"ISPTECORE" boolean)
 returns table("AttemptedAnswers" jsonb[],
"OptionNames" character varying,
"AnswerNames" character varying)
 language plpgsql
as $function$
	declare
		result_array JSONB[];

related_data JSONB[];

option_names_var character varying;

answer_names_var character varying;

begin
		
	select
	array(
	select
		jsonb_build_object(
    'AttemptedQuestionId',
		aq.id ,
		'MarksObtained',
		aq.marks_obtained,
		'UsersResponse',
		aq.users_response,
		'TimeTaken',
		aq.time_taken,
		'CreatedAt',
		aq.created_at ,
		'UserName' ,
		u.name ,
		'UserId' ,
		u.id ,
		'UserImage' ,
		u.image_url,
		'IsLiked',
		exists (
		select
			1
		from
			public.attempted_questions_likes aqlinner
		where
			aqlinner.attempted_question_id = aq.id
			and aqlinner.user_id = $2),
		'TotalLikes',
		(
		select
			count(aqllikes.id)
		from
			public.attempted_questions_likes aqllikes
		where
			aqllikes.attempted_question_id = aq.id
	))
	from
		public.test_questions tq
	right join public.attempted_questions aq on
		tq.id = aq.test_question_id
	inner join public.users u
    on
		aq.user_id = u.id
	where
		tq.id = $1
		and aq.user_id != $2
		and aq.is_ptecore = $5
	order by
		aq.created_at desc
	limit $3 offset $4
)
into
	result_array ;

if array_length(result_array,
1) > 0 then
    for i in array_lower(result_array, 1)..array_upper(result_array, 1) loop
        select
	array(
	select
		jsonb_build_object(
            'CommentId',
		aqc.id,
			'UserId',
		aqc.user_id,
			'CreatedAt',
		to_char(aqc.craeted_at at TIME zone 'UTC',
		'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
			'UserName' ,
		uu.name ,
		    'UserImage' ,
		uu.image_url,
			'Comment',
		aqc.attempted_questions_comment,
			'IsLiked',
		exists (
		select
			1
		from
			public.attempted_questions_comment_likes aqclinner
		where
			aqclinner.attempted_questions_comment_id = aqc.id
			and aqclinner.user_id = $2),
			'TotalLikes',
		(
		select
			count(aqcllikes.id)
		from
			public.attempted_questions_comment_likes aqcllikes
		where
			aqcllikes.attempted_questions_comment_id = aqc.id)
			)
	from
		attempted_questions_comments aqc
	left join public.attempted_questions_comment_likes aqcl
            on
		aqc.id = aqcl.attempted_questions_comment_id
	left join public.users uu
            on
		aqc.user_id = uu.id
	where
		aqc.attempted_question_id = (result_array[i] ->> 'AttemptedQuestionId')::int
        )
into
	related_data;

result_array[i] := jsonb_set(result_array[i],
'{Comments}',
to_jsonb(related_data));
end loop;
end if;

if exists(
select
	1
from
	"options"
where
	question_id in (
	select
		question_id
	from
		public.test_questions
	where
		id = $1)) then
			select
	option_names ,
	answer_names
into
	option_names_var,
	answer_names_var
from
	"options"
where
	question_id in (
	select
		question_id
	from
		public.test_questions
	where
		id = $1);
else
			option_names_var := null;

answer_names_var := null;
end if;

return QUERY
select
	result_array,
	option_names_var,
	answer_names_var;
end;

$function$
;
-- DROP FUNCTION public.get_average_score_of_mock_tests_of_user(int4);

create or replace
function public.get_average_score_of_mock_tests_of_user("USERID" integer)
 returns table("MockTestAttemptId" integer,
"MockTestId" integer,
"MockTestName" character varying,
"UserResponse" text)
 language plpgsql
as $function$
begin
    return QUERY
    select
	filtered_mta.id as "MockTestAttemptId",
	mt.id as "MockTestId",
	mt.name as "MockTestName",
	maq.users_response as "UserResponse"
from
	(
	select
		*
	from
		public.mock_test_attempts
	where
		user_id = $1
		and status = 'completed'
	order by
		id desc
	limit 4
    ) as filtered_mta
left join public.mock_test mt 
        on
	filtered_mta.mock_test_id = mt.id
left join public.mock_test_questions mtq 
        on
	filtered_mta.mock_test_id = mtq.mock_test_id
left join public.mock_attempted_questions maq
        on
	mtq.id = maq.mock_test_question_id
	and maq.user_id = $1;
end
$function$
;
-- DROP FUNCTION public.get_average_score_of_user(int4);

create or replace
function public.get_average_score_of_user("USERID" integer)
 returns table("CategoryName" character varying,
"AvgPercentage" numeric,
"TotalMarksObtained" integer,
"TotalMarks" integer)
 language sql
as $function$
    select
	tc.category_name,
	ROUND(cast(SUM(aq.marks_obtained) * 100.0 / nullif(SUM(q.total_marks),
	0)as numeric),
	0) as "AvgPercentage",
	SUM(aq.marks_obtained) as total_marks_obtained,
	SUM(q.total_marks) as total_marks
from
	public.attempted_questions aq
left join public.test_questions tq on
	aq.test_question_id = tq.id
left join public.test t on
	tq.test_id = t.id
left join public.question q on
	tq.question_id = q.id
left join public.test_categories tc on
	t.category_id = tc.id
where
	aq.user_id = $1
	and aq.is_ptecore = false
group by
	tc.category_name
order by
	tc.category_name;

$function$
;
-- DROP FUNCTION public.get_branch_by_id(varchar);

create or replace
function public.get_branch_by_id("BRANCH_ID" character varying)
 returns table("Id" character varying,
"Name" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"PortalId" integer)
 language plpgsql
as $function$
begin
    return QUERY
    select
	id,
	"name",
	created_at,
	updated_at,
	portal_id
from
	public.branches
where
	id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_branches_by_portal_id(int4);

create or replace
function public.get_branches_by_portal_id("PORTAL_ID" integer)
 returns table("Id" character varying,
"Name" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"PortalId" integer)
 language plpgsql
as $function$
begin
    return QUERY
    select
	id,
	"name",
	created_at,
	updated_at,
	portal_id
from
	public.branches
where
	portal_id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_comments(int4, int4);

create or replace
function public.get_comments("TESTQUESTIONID" integer,
"USERID" integer)
 returns table("CommentId" integer,
"Comment" character varying,
"CommentImg" character varying,
"Category" character varying,
"CreatedAt" text,
"UserId" integer,
"UserName" character varying,
"UserImageUrl" character varying,
"IsLiked" boolean,
"Replies" json)
 language plpgsql
as $function$
begin
    return QUERY 
    with recursive comment_tree as (
select
	c.id as "CommentId",
	c.comment as "Comment",
	c.comment_img as "CommentImg",
	c.category as "Category",
	to_char(c.craeted_at at TIME zone 'UTC',
	'YYYY-MM-DD"T"HH24:MI:SS"Z"') as "CreatedAt",
	c.user_id as "UserId",
	u.name as "UserName",
	u.image_url as "UserImageUrl",
	exists(
	select
		1
	from
		public.comment_likes
	where
		c.user_id = $2
		and comment_id = c.id),
	case
		when COUNT(sub.id) = 0 then null
		else json_agg(
                    json_build_object(
                        'ReplyId',
		sub.id,
		'Reply',
		sub.comment,
		'ReplyImg',
		sub.comment_img,
			            'CreatedAt',
		to_char(sub.craeted_at at TIME zone 'UTC',
		'YYYY-MM-DD"T"HH24:MI:SS"Z"'),
		'UserId',
		sub.user_id,
		'UserName',
		u2.name,
		'UserImageUrl',
		u2.image_url,
		'IsLiked',
		exists(
		select
			1
		from
			public.comment_likes
		where
			sub.user_id = $2
			and comment_id = sub.id)
                    )
	order by
		sub.craeted_at asc
                )
	end as "Replies"
from
	"comments" c
left join
            "users" u on
	c.user_id = u.id
left join
            "comments" sub on
	c.id = sub.parent_id
left join
            "users" u2 on
	sub.user_id = u2.id
where
	c.test_question_id = $1
	and c.parent_id is null
group by
	c.id,
	u.name,
	u.image_url
order by
	c.craeted_at desc
    )
    select
	*
from
	comment_tree;
end;

$function$
;
-- DROP FUNCTION public.get_deleted_users();

create or replace
function public.get_deleted_users()
 returns table("UserID" integer)
 language plpgsql
as $function$
	begin
		return query
		select
	id
from
	public.users
where
	is_deleted = true
order by
	id desc;
end;

$function$
;
-- DROP FUNCTION public.get_last_attempted_mock_tests_of_user_of_organization(int4);

create or replace
function public.get_last_attempted_mock_tests_of_user_of_organization("PORTALID" integer)
 returns table("MockTestAttemptId" integer,
"MockTestName" character varying,
"DateTaken" timestamp without time zone,
"TestType" character varying,
"UserId" integer,
"UserName" character varying)
 language plpgsql
as $function$
begin
  return QUERY
  select
	mta.id as "MockTestAttemptId",
	mt.name as "MockTestName",
	mta.updated_at as "DateTaken",
	coalesce(mtt.name,
	'Full') as "TestType",
	u.id as "UserId",
	u.name as "UserName"
from
	public.portal p
left join public.users u 
    on
	p.id = u.portal_id
left join lateral (
	select
		*
	from
		public.mock_test_attempts mta
	where
		mta.user_id = u.id
		and mta.status = 'completed'
	order by
		mta.updated_at desc
	limit 1
  ) mta 
    on
	true
left join public.mock_test mt 
    on
	mta.mock_test_id = mt.id
left join public.mock_test_types mtt 
    on
	mt.mock_test_type_id = mtt.id
where
	p.id = "PORTALID";
end;

$function$
;
-- DROP FUNCTION public.get_mock_test_questions_by_test_id(int4, int4);

create or replace
function public.get_mock_test_questions_by_test_id("MOCKTESTTID" integer,
"USERID" integer)
 returns table("MockTestAttemptId" integer,
"MockTestQuestionTableId" integer,
"QuestionId" integer,
"QuestionName" character varying,
"QuestionStatement" character varying,
"Category" character varying,
"SubCategory" character varying)
 language plpgsql
as $function$
declare 
	mock_test_attempt_id_ integer;

begin
		if (not exists(
select
	1
from
	public.mock_test_attempts
where
	mock_test_id = $1
	and user_id = $2
	and status = 'pending')) then
			insert
	into
	public.mock_test_attempts(mock_test_id,
	user_id)
values ($1,
$2) returning id
into
	mock_test_attempt_id_;
end if;

return query
		select
	mock_test_attempt_id_,
	mtq.id,
	mtq.question_id ,
	q.name ,
	q.statement ,
	tc.category_name,
	t.test_name
from
	public.mock_test_questions mtq
left join public.question q
		on
	mtq.question_id = q.id
left join public.test t
		on
	q.test_id = t.id
left join public.test_categories tc
		on
	t.category_id = tc.id
where
	mtq.mock_test_id = $1
order by
	        case
		q.test_id
	            when 18 then 1
		when 19 then 2
		when 24 then 3
		when 21 then 4
		when 25 then 5
		when 20 then 6
		when 7 then 7
		when 6 then 8
		when 23 then 9
		when 1 then 10
		when 2 then 11
		when 3 then 12
		when 4 then 13
		when 5 then 14
		when 17 then 15
		when 15 then 16
		when 9 then 17
		when 10 then 18
		when 16 then 19
		when 11 then 20
		when 12 then 21
		when 14 then 22
	end;
end;

$function$
;
-- DROP FUNCTION public.get_mock_test_questions_by_test_id_for_admin(int4);

create or replace
function public.get_mock_test_questions_by_test_id_for_admin("MOCKTESTTID" integer)
 returns table("MockTestQuestionTableId" integer,
"QuestionId" integer,
"QuestionName" character varying,
"QuestionStatement" character varying,
"Category" character varying,
"SubCategory" character varying)
 language plpgsql
as $function$
begin
    return query
    select
	mtq.id,
	mtq.question_id,
	q.name,
	q.statement,
	tc.category_name,
	t.test_name
from
	public.mock_test_questions mtq
left join 
        public.question q on
	mtq.question_id = q.id
left join 
        public.test t on
	q.test_id = t.id
left join 
        public.test_categories tc on
	t.category_id = tc.id
where
	mtq.mock_test_id = $1
order by
	case
		q.test_id
	            when 18 then 1
		when 19 then 2
		when 24 then 3
		when 21 then 4
		when 25 then 5
		when 20 then 6
		when 7 then 7
		when 6 then 8
		when 23 then 9
		when 1 then 10
		when 2 then 11
		when 3 then 12
		when 4 then 13
		when 5 then 14
		when 17 then 15
		when 15 then 16
		when 9 then 17
		when 10 then 18
		when 16 then 19
		when 11 then 20
		when 12 then 21
		else 14
	end;
end;

$function$
;
-- DROP FUNCTION public.get_mock_test_questions_if_pending(int4, int4);

create or replace
function public.get_mock_test_questions_if_pending("MOCKTESTATTEMPTID" integer,
"USERID" integer)
 returns table("MockTestQuestionTableId" integer,
"QuestionId" integer,
"QuestionName" character varying,
"QuestionStatement" character varying,
"Category" character varying,
"SubCategory" character varying,
"IsAttempted" boolean,
"TimeTaken" integer,
"AllTimes" text)
 language plpgsql
as $function$
declare 
	mock_test_id_ integer;

begin
		select
	mock_test_id
into
	mock_test_id_
from
	public.mock_test_attempts mta
where
	mta.id = $1;

return query
		select
	mtq.id,
	mtq.question_id ,
	q.name ,
	q.statement ,
	tc.category_name,
	t.test_name,
		exists(
	select
		1
	from
		public.mock_attempted_questions maq
	where
		maq.mock_test_attempt_id = $1
		and maq.user_id = $2
		and maq.mock_test_question_id = mtq.id),
		(
	select
		maq.time_taken
	from
		public.mock_attempted_questions maq
	where
		maq.mock_test_attempt_id = $1
		and maq.user_id = $2
		and maq.mock_test_question_id = mtq.id
	limit 1),		
		(
	select
		maq.alltimes
	from
		public.mock_attempted_questions maq
	where
		maq.mock_test_attempt_id = $1
		and maq.user_id = $2
		and maq.mock_test_question_id = mtq.id
	limit 1)
from
	public.mock_test_questions mtq
left join public.question q
		on
	mtq.question_id = q.id
left join public.test t
		on
	q.test_id = t.id
left join public.test_categories tc
		on
	t.category_id = tc.id
where
	mtq.mock_test_id = mock_test_id_
order by
	        case
		q.test_id
	            when 18 then 1
		when 19 then 2
		when 24 then 3
		when 21 then 4
		when 25 then 5
		when 20 then 6
		when 7 then 7
		when 6 then 8
		when 23 then 9
		when 1 then 10
		when 2 then 11
		when 3 then 12
		when 4 then 13
		when 5 then 14
		when 17 then 15
		when 15 then 16
		when 9 then 17
		when 10 then 18
		when 16 then 19
		when 11 then 20
		when 12 then 21
		when 14 then 22
	end;
end;

$function$
;
-- DROP FUNCTION public.get_mock_test_user_attempted_count(int4, bool);

create or replace
function public.get_mock_test_user_attempted_count("USERID" integer,
"ISPTECORE" boolean)
 returns table("TotalMockTests" integer,
"AttemptedMockTests" integer)
 language plpgsql
as $function$
	declare 
		total_ integer;

attempted_ integer;

begin
		select
	count(*)
into
	total_
from
	public.mock_test;

select
	COUNT(*)
into
	attempted_
from
	(
	select
		distinct user_id
	from
		public.mock_test_attempts
	where
		user_id = $1
		and status = 'completed'
		) as distinct_attempts;

return query
		select
	total_,
	attempted_;
end;

$function$
;
-- DROP FUNCTION public.get_plans_by_branch_id(varchar);

create or replace
function public.get_plans_by_branch_id("BRANCHID" character varying)
 returns table("Id" character varying,
"Name" character varying,
"PortalId" integer,
"BranchCount" integer,
"PlanName" character varying,
"PlanDesc" character varying,
"AssigneableAccounts" integer,
"PlanId" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    select
	b.id,
	b."name",
	b.portal_id,
	coalesce(
            (
	select
		value::int
	from
		jsonb_each_text(wta.branches)
	where
		key = b.id),
	0) as "BranchCount",
		pfw."name",
		pfw.plan,
		(wta.total_accounts - wta.assigned),
		pfw.id
from
	public.branches b
left join 
        public.white_label_total_accounts wta
        on
	b.portal_id = wta.portal_id
left join 
		public.plans_for_whitelabels pfw
		on
	wta.plan_id = pfw.id
where
	b.id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_plans_with_subplans(varchar);

create or replace
function public.get_plans_with_subplans("COUNTRYID" character varying)
 returns jsonb
 language plpgsql
as $function$
declare
    result jsonb;

begin
-- Build the JSON result using CTEs to avoid nested aggregation
    with plan_subplan as (
select
	p."name" as plan_name,
	p.id as plan_id,
	p.days as plan_days,
	-- Correct reference to `days`
	b.id as bridge_id,
	s."name" as subplan_name,
	b.price_per_account,
	b.created_at,
	b.updated_at
from
	public.plans_for_whitelabels p
join
            public.bridge_paln_subplans b on
	p.id = b.plan_id
	and p.country_id = $1
join
            public.subplans_for_whitelabels s on
	b.subplan_id = s.id
	and s.mock_only = false
    ),
    aggregated_subplans as (
select
	plan_name,
	plan_id,
	plan_days,
	-- Propagate plan_days to this CTE
	jsonb_agg(
                jsonb_build_object(
                    'id',
	bridge_id,
	'name',
	subplan_name,
	'price_per_account',
	price_per_account,
	'created_at',
	created_at,
	'updated_at',
	updated_at
                )
            ) as subplans
from
	plan_subplan
group by
	plan_name,
	plan_id,
	plan_days
	-- Include plan_days in GROUP BY
    )
    select
	jsonb_agg(
            jsonb_build_object(
                'plan_name',
	plan_name,
	'plan_id',
	plan_id,
	'plan_days',
	plan_days,
	-- Include plan_days in final JSON
                'subplans',
	subplans
            )
order by
	plan_days::int4
        )
    into
	result
from
	aggregated_subplans;

return result;
end;

$function$
;
-- DROP FUNCTION public.get_plans_with_subplans_mockonly(varchar);

create or replace
function public.get_plans_with_subplans_mockonly("COUNTRYID" character varying)
 returns jsonb
 language plpgsql
as $function$
declare
    result jsonb;

begin
-- Build the JSON result using CTEs to avoid nested aggregation
    with plan_subplan as (
select
	p."name" as plan_name,
			p.id as plan_id,
	b.id as bridge_id,
	s."name" as subplan_name,
	b.price_per_account,
	b.created_at,
	b.updated_at
from
	public.plans_for_whitelabels p
join
            public.bridge_paln_subplans b on
	p.id = b.plan_id
	and p.country_id = $1
join
            public.subplans_for_whitelabels s on
	b.subplan_id = s.id
	and s.mock_only = true
    ),
    aggregated_subplans as (
select
	plan_name,
			plan_id,
	jsonb_agg(
                jsonb_build_object(
                    'id',
	bridge_id,
	'name',
	subplan_name,
	'price_per_account',
	price_per_account,
	'created_at',
	created_at,
	'updated_at',
	updated_at
                )
            ) as subplans
from
	plan_subplan
group by
	plan_name,
	plan_id
    )
    select
	jsonb_agg(
        jsonb_build_object(
            'plan_name',
	plan_name,
			'plan_id',
	plan_id,
	'subplans',
	subplans
        )
    )
into
	result
from
	aggregated_subplans;

return result;
end;

$function$
;
-- DROP FUNCTION public.get_portal_by_id(int4);

create or replace
function public.get_portal_by_id("PORTALID" integer)
 returns table("PortalName" character varying,
"PortalLink" character varying,
"PortalOwnerName" character varying,
"Location" character varying,
"CreatedAt" timestamp without time zone,
"CountryName" character varying)
 language plpgsql
as $function$
	begin
		return query
		select 
			p.portal_name,
			p.portal_link,
			p.portal_owner_name,
			p.location,
			p.created_at,
	c.name
from
	public.portal p
left join public.countries c
            on
	p.country_id = c.id
where
	p.id = $1
;
end;

$function$
;
-- DROP FUNCTION public.get_portal_configuration(int4);

create or replace
function public.get_portal_configuration("PORTALID" integer)
 returns table("StrategyVideoVisible" boolean,
"TemplateVisible" boolean,
"GrammarVisible" boolean,
"SelfStrategyVideoVisible" boolean,
"SelfTemplateVisible" boolean,
"SelfGrammarVisible" boolean)
 language plpgsql
as $function$
	begin
		return query
		select 
			P.strategy_video_visible,
			P.template_visible,
			P.grammar_visible,
			P.self_strategy_video_visible,
			P.self_template_visible,
			P.self_grammar_visible
from
	public.portal p
where
	p.id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_portal_info(varchar, bool);

create or replace
function public.get_portal_info("PORTALURL" character varying,
"ISADMIN" boolean)
 returns setof portal
 language plpgsql
as $function$
	begin
		if $2 = true then
		return query
		select
	*
from
	public.portal p
where
	p.admin_portal_link = $1;
else
			return query
			select
	*
from
	public.portal p
where
	p.portal_link = $1;
end if;
end;

$function$
;
-- DROP FUNCTION public.get_portal_info_by_id(int4);

create or replace
function public.get_portal_info_by_id("PORTALID" integer)
 returns setof portal
 language plpgsql
as $function$
	begin
		return query
		select
	*
from
	public.portal p
where
	p.id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_portal_info_for_users(varchar);

create or replace
function public.get_portal_info_for_users("PortalLink" character varying)
 returns setof portal
 language plpgsql
as $function$
	begin
		return query
		select
	*
from
	public.portal p
where
	p.portal_link ilike($1);
end;

$function$
;
-- DROP FUNCTION public.get_portal_metrics(int4, int4);

create or replace
function public.get_portal_metrics("PORTALID" integer,
"ADMINID" integer)
 returns json
 language plpgsql
as $function$
declare
    result json;

branch_id_ character varying;

begin
    select
	a.branch_id
into
	branch_id_
from
	public.admins a
where
	a.id = $2;

with LoggedInUsers as (
select
	COUNT(*) as logged_in_count
from
	public.users
where
	portal_id = $1
	and sessionid is not null
	and session_expiry > NOW()
	and (branch_id = branch_id_
		or branch_id_ is null)
    ),
    SubscribedUsers as (
select
	COUNT(*) as subscribed_count
from
	public.users
where
	portal_id = $1
	and is_subscribed = true
	and (branch_id = branch_id_
		or branch_id_ is null)
    ),
    ExpiringSubscriptions as (
select
	COUNT(*) as expiring_count
from
	public.users u
join public.subscriptions s on
	u.subscription_id = s.id
where
	u.portal_id = $1
	and u.is_subscribed = true
	and u.subscription_id is not null
	and u.subscription_time is not null
	and (u.subscription_time + (s.days * interval '1 day')) between NOW() and (NOW() + interval '2 days')
		and (u.branch_id = branch_id_
			or u.branch_id is null)
    ),
    TotalUsers as (
select
	COUNT(*) as total_users
from
	public.users
where
	portal_id = $1
	and is_deleted = false
	and (branch_id = branch_id_
		or branch_id_ is null)
    ),
    CompletedTests as (
select
	COUNT(*) as completed_tests
from
	public.mock_test_attempts mta
join public.users u on
	u.id = mta.user_id
where
	u.portal_id = $1
	and mta.status = 'completed'
	and (u.branch_id = branch_id_
		or u.branch_id is null)
    ),
    MonthlyTests as (
select
	TO_CHAR(mta.created_at,
	'Mon') as month,
	COUNT(*) as count
from
	public.mock_test_attempts mta
join public.users u on
	u.id = mta.user_id
where
	u.portal_id = $1
	and mta.status = 'completed'
	and extract(year
from
	mta.created_at) = extract(year
from
	CURRENT_DATE)
	and (u.branch_id = branch_id_
		or u.branch_id is null)
group by
	TO_CHAR(mta.created_at,
	'Mon'),
	extract(month
from
	mta.created_at)
    ),
    AllMonths as (
select
	TO_CHAR(DATE_TRUNC('month',
	gs.date),
	'Mon') as month
from
	generate_series(
            DATE_TRUNC('year',
	CURRENT_DATE),
	DATE_TRUNC('month',
	CURRENT_DATE),
	'1 month'::interval
        ) gs(date)
    ),
    WhiteLabelAccounts as (
select
	p.name,
	case
		when branch_id_ is not null then 
                    coalesce((w.branches ->> branch_id_)::INTEGER,
		0)
		else 
                    coalesce(w.total_accounts,
		0) 
                    - coalesce(
                        (
		select
			SUM(value::INTEGER)
		from
			jsonb_each_text(w.branches)),
		0)
	end as total_accounts
from
	public.plans_for_whitelabels p
left join public.white_label_total_accounts w 
            on
	p.id = w.plan_id
	and w.portal_id = $1
    ),
    MetricsCTE as (
select
	json_build_object(
            'logged_in_users',
	(
	select
		logged_in_count
	from
		LoggedInUsers),
	'subscribed_users',
	(
	select
		subscribed_count
	from
		SubscribedUsers),
	'expiring_subscriptions_count',
	(
	select
		expiring_count
	from
		ExpiringSubscriptions),
	'total_users',
	(
	select
		total_users
	from
		TotalUsers),
	'completed_tests',
	(
	select
		completed_tests
	from
		CompletedTests),
	'monthly_test_completion',
	(
	select
		json_agg(json_build_object(am.month,
		coalesce(mt.count,
		0)))
	from
		AllMonths am
	left join MonthlyTests mt on
		am.month = mt.month
            ),
	'premium_account',
	(
	select
		json_object_agg(name,
		total_accounts)
	from
		(
		select
			name,
			SUM(total_accounts) as total_accounts
		from
			WhiteLabelAccounts
		group by
			name) aggregated_accounts
            )
        ) as json_obj
    )
    
    select
	json_obj
into
	result
from
	MetricsCTE;

return result;
end;

$function$
;
-- DROP FUNCTION public.get_portal_transactions(int4, varchar);

create or replace
function public.get_portal_transactions("PORTALID" integer,
"REFERENCENUMBER" character varying)
 returns table("TransactionID" character varying,
"AdminID" integer,
"PortalID" integer,
"PlanID" character varying,
"Status" character varying,
"RequestPayload" character varying,
"ResponsePayload" character varying,
"BankAlfalahSubscriptionID" character varying,
"PromocodeID" character varying,
"Country" character varying,
"Currency" character varying,
"Phone" character varying,
"Email" character varying,
"OrderID" character varying,
"TransactionReferenceNumber" character varying,
"TransactionExternalID" character varying,
"TransactionAmount" character varying,
"TransactionDescription" character varying,
"TransactionStatus" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"ImageURL" character varying,
"IsApproved" boolean,
"NoOfAccountsPurchased" character varying,
"NoOfAccountsUsed" character varying,
"AmountPaid" character varying,
"ReferenceNumber" character varying,
"Location" character varying,
"BoughtByAndReason" text,
"Manual" character varying,
"Plan" character varying,
"AdminName" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    select
	t.id as "TransactionID",
	t.admin_id as "AdminID",
	t.portal_id as "PortalID",
	t.plan_id as "PlanID",
	t.status as "Status",
	t.request_payload as "RequestPayload",
	t.response_payload as "ResponsePayload",
	t.bank_alfalah_subscription_id as "BankAlfalahSubscriptionID",
	t.promocode_id as "PromocodeID",
	t.country as "Country",
	t.currency as "Currency",
	t.phone as "Phone",
	t.email as "Email",
	t.order_id as "OrderID",
	t.transaction_reference_number as "TransactionReferenceNumber",
	t.transaction_id as "TransactionExternalID",
	t.transaction_amount as "TransactionAmount",
	t.transaction_description as "TransactionDescription",
	t.transaction_status as "TransactionStatus",
	t.created_at as "CreatedAt",
	t.updated_at as "UpdatedAt",
	t.image_url as "ImageURL",
	t.is_approved as "IsApproved",
	t.no_of_accounts_purchased as "NoOfAccountsPurchased",
	t.no_of_accounts_used as "NoOfAccountsUsed",
	t.amount_paid as "AmountPaid",
	t.reference_number as "ReferenceNumber",
	t.location as "Location",
	t.bought_by_and_reason as "BoughtByAndReason",
	t.manual as "Manual",
	p.plan as "Plan",
		a.name as "AdminName"
from
	public.whitelabel_transactions t
left join 
        public.plans_for_whitelabels p
    on
	t.plan_id = p.id
left join 
		public.admins a
	on
		t.admin_id = a.id
where
	(t.portal_id = $1
		or $1 is null)
	and (t.reference_number ilike $2
		or $2 is null)
order by
	t.created_at;
end;

$function$
;
-- DROP FUNCTION public.get_promo_code_by_id(varchar);

create or replace
function public.get_promo_code_by_id("PROMOCODEID" character varying)
 returns table("Percentage" integer,
"FixedAmount" integer)
 language plpgsql
as $function$
begin
    return QUERY
    select
	percentage,
	fixed_amount
from
	public.promo_codes
where
	id = $1
	and active = true
	and expiry_date > now();
end;

$function$
;
-- DROP FUNCTION public.get_promo_code_by_id_for_user(varchar, int4);

create or replace
function public.get_promo_code_by_id_for_user("PROMOCODEID" character varying,
"USERID" integer)
 returns table("Percentage" integer,
"FixedAmount" integer)
 language plpgsql
as $function$
begin
    return QUERY
    select
	pc.percentage,
	pc.fixed_amount
from
	public.promo_codes pc
left join 
	public.users u
	on
	pc.portal_id = u.portal_id
where
	pc.id = $1
	and u.id = $2
	and pc.active = true
	and (pc.user_id = $2
		or pc.user_id is null)
	and (pc.portal_id is null
		or pc.portal_id = u.portal_id)
	and count - temp_count > 0
	and expiry_date > now();
end;

$function$
;
-- DROP FUNCTION public.get_promo_code_by_id_for_whitelabel_admin(varchar, int4);

create or replace
function public.get_promo_code_by_id_for_whitelabel_admin("PROMOCODEID" character varying,
"PORTALID" integer)
 returns table("Percentage" integer,
"FixedAmount" integer)
 language plpgsql
as $function$
begin
    return QUERY
    select
	percentage,
	fixed_amount
from
	public.promo_codes
where
	id = $1
	and active = true
	and (portal_id = $2
		or portal_id is null)
	and count - temp_count > 0
	and expiry_date > now();
end;

$function$
;
-- DROP FUNCTION public.get_question_with_options(int4, int4, int4);

create or replace
function public.get_question_with_options("QUESTIONID" integer,
"USERID" integer,
"TESTQUESTIONID" integer)
 returns table("QuestionStatement" character varying,
"AudioObject" character varying,
"MajorAspects" character varying,
"MinorAspects" character varying,
"OptionNames" character varying,
"AnswerNames" character varying,
"OptionText" character varying,
"IsBookMarked" boolean,
"BookMarkedId" integer,
"AppearedCount" integer,
"TestQuestionNoteId" integer,
"TestQuestionNoteText" character varying,
"QuestionImage" character varying,
"Prediction" boolean,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
	declare 
		count_of_appeared integer = 0;

begin
		select
	cast(count(apq.id) as integer)
into
	count_of_appeared
from
		public.appeared_questions apq
where
	apq.question_id = $1;

return query
		select
	q.statement,
	q.audio_object ,
	q.major_aspects ,
		q.minor_aspects ,
	o.option_names ,
	o.answer_names ,
	o.option_text,
		exists (
	select
		1
	from
		public.bookmarks b ,
		public.test_questions tq
	where
		tq.id = b.test_question_id
		and b.user_id = $2
		and tq.id = $3) ,
		(
	select
		b.id
	from
		public.bookmarks b ,
		public.test_questions tq
	where
		tq.id = b.test_question_id
		and b.user_id = $2
		and tq.id = $3) as bookMarkedId,
		count_of_appeared ,
	tqn.id ,
	tqn.note ,
	q.question_image ,
	q.prediction ,
	q.created_at ,
	q.updated_at
from
	public.question q
left join public.options o
		on
	q.id = o.question_id
left join public.test_question_notes tqn 
		on
	q.id = tqn.test_question_id
	and tqn.user_id = $2
where
	q.id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_question_with_options_for_admin(int4, int4);

create or replace
function public.get_question_with_options_for_admin("QUESTIONID" integer,
"TESTQUESTIONID" integer)
 returns table("QuestionStatement" character varying,
"AudioObject" character varying,
"MajorAspects" character varying,
"MinorAspects" character varying,
"OptionNames" character varying,
"AnswerNames" character varying,
"OptionText" character varying,
"AppearedCount" integer,
"QuestionImage" character varying,
"Prediction" boolean,
"OptionId" integer)
 language plpgsql
as $function$
	declare 
		count_of_appeared integer = 0;

begin
		select
	cast(count(apq.id) as integer)
into
	count_of_appeared
from
		public.appeared_questions apq
where
	apq.question_id = $1;

return query
		select
	q.statement,
	q.audio_object ,
	q.major_aspects ,
		q.minor_aspects ,
	o.option_names ,
	o.answer_names ,
	o.option_text,
		count_of_appeared ,
	q.question_image,
	q.prediction ,
	o .id
from
	public.question q
left join public.options o
		on
	q.id = o.question_id
where
	q.id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_question_with_options_for_mock(int4);

create or replace
function public.get_question_with_options_for_mock("QUESTIONID" integer)
 returns table("QuestionStatement" character varying,
"AudioObject" character varying,
"MajorAspects" character varying,
"MinorAspects" character varying,
"OptionNames" character varying,
"AnswerNames" character varying,
"OptionText" character varying,
"QuestionImage" character varying,
"Prediction" boolean)
 language plpgsql
as $function$
	begin
		return query
		select
	q.statement,
	q.audio_object ,
	q.major_aspects ,
		q.minor_aspects ,
	o.option_names ,
	o.answer_names ,
	o.option_text,
	q.question_image,
	q.prediction
from
	public.question q
left join public.options o
		on
	q.id = o.question_id
where
	q.id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_remaining_free_tokens(int4);

create or replace
function public.get_remaining_free_tokens("USERID" integer)
 returns table("NonAITokens" integer,
"SpeakingTokens" integer,
"WritingTokens" integer)
 language plpgsql
as $function$
	begin
		return query
		select
	non_ai,
	speaking,
	writing
from
	public.users
where
	id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_score_of_mock_test(int4);

create or replace
function public.get_score_of_mock_test("MOCKTESTATTEMPTID" integer)
 returns table("MockTestName" character varying,
"AttemptedAt" timestamp without time zone,
"UserResponse" text,
"TimeTaken" integer,
"AudioURL" character varying)
 language plpgsql
as $function$
	begin
--		select analytics from public.mock_test_attempts
--		where id =$1;
		return query
		select 
		mt.name,
		mta.created_at,
		maq.users_response,
		maq.time_taken,
		maq.audio_url
from
	public.mock_test_attempts mta
left join public.mock_test mt
		on
	mta.mock_test_id = mt.id
left join public.mock_attempted_questions maq 
		on
	mta.id = maq.mock_test_attempt_id
where
	mta.id = $1
order by
	maq.created_at;
end;

$function$
;
-- DROP FUNCTION public.get_score_of_mock_test_for_admin(int4, int4);

create or replace
function public.get_score_of_mock_test_for_admin("MOCKTESTATTEMPTID" integer,
"USERID" integer)
 returns table("MockTestName" character varying,
"AttemptedAt" timestamp without time zone,
"UserResponse" text,
"TimeTaken" integer,
"AudioURL" character varying)
 language plpgsql
as $function$
	begin
--		select analytics from public.mock_test_attempts
--		where id =$1;
		return query
		select 
		mt.name,
		mta.created_at,
		maq.users_response,
		maq.time_taken,
		maq.audio_url
from
	public.mock_test_attempts mta
left join public.mock_test mt
		on
	mta.mock_test_id = mt.id
left join public.mock_attempted_questions maq 
		on
	mta.id = maq.mock_test_attempt_id
where
	mta.id = $1
	and mta.user_id = $2
order by
	maq.created_at;
end;

$function$
;
-- DROP FUNCTION public.get_strategy_video_of_portal(bool, int4);

create or replace
function public.get_strategy_video_of_portal("CORE" boolean,
"PORTALID" integer)
 returns table("Id" integer,
"Title" character varying,
"Author" character varying,
"YtLink" character varying,
"Category" character varying,
"Priority" integer,
"Language" character varying,
"Core" boolean,
"Thumbnail" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone)
 language plpgsql
as $function$
declare
	strategy_video_visible_ boolean;

begin
	select 
		strategy_video_visible
	into 
		strategy_video_visible_
from
	public.portal
where
	id = $2;

return QUERY
	select
		sv.id,
		sv.title,
		sv.author,
		sv.yt_link,
		sv.category,
		sv.priority,
		sv."language",
		sv.core,
		sv.thumbnail,
		sv.created_at,
		sv.updated_at
from
		public.strategy_video sv
where 
		sv.core = $1
	and (
			sv.portal_id = $2
		or (strategy_video_visible_
			and sv.portal_id = 1)
		);
end;

$function$
;
-- DROP FUNCTION public.get_student_by_admin(int4, varchar, bool, varchar, varchar);

create or replace
function public.get_student_by_admin("PORTALID" integer,
"NAME" character varying,
"SUBSCRIBED" boolean,
"TYPE" character varying,
"BRANCHNAME" character varying)
 returns table("Id" integer,
"Email" character varying,
"Name" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"Type" character varying,
"IsSubscribed" boolean,
"SessionID" character varying,
"ExpiryTime" timestamp with time zone,
"PlanName" character varying,
"TimeUntilExpiry" timestamp with time zone,
"BranchID" character varying,
"BranchName" character varying,
"UserImage" character varying,
"ExamTarget" text,
"IsEmailVerified" boolean,
"CountryCode" character varying,
"PhoneNumber" character varying,
"IsDeleted" boolean,
"City" character varying,
"ExamDate" timestamp without time zone,
"SubscriptionId" character varying,
"PlanId" character varying,
"PlanNameN" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    select
	u.id,
	u.email,
	u."name",
	u.created_at,
	u.updated_at,
	u.type,
	u.is_subscribed,
	u.sessionid,
	u.session_expiry,
	s.name,
	(
  case
		when s.days is not null then 
      ((u.subscription_time + (s.days || ' days')::interval) at TIME zone 'UTC')::timestamptz
		when pfw.days is not null then 
      ((u.subscription_time + (pfw.days || ' days')::interval) at TIME zone 'UTC')::timestamptz
		else 
      null
	end
) as "TimeUntilExpiry",
	b.id,
	b.name,
		u.image_url,
		u.exam_target,
		u.is_email_verified,
		u.country_code,
		u.phone_number,
		u.is_deleted,
		u.city,
		u.exam_date,
		u.subscription_id,
		u.plan_id,
		pfw.plan
from
	public.users u
left join public.subscriptions s
        on
	u.subscription_id = s.id
left join public.branches b
        on
	u.branch_id = b.id
left join public.plans_for_whitelabels pfw
		on
	u.plan_id = pfw.id
where
	u.is_deleted = false
	and u.deleted_from_trash = false
	and u.portal_id = $1
	and (u."name" ilike $2
		or $2 is null)
	and (u.is_subscribed = $3
		or $3 is null)
	and (u.type ilike $4
		or $4 is null)
	and ((b.name ilike $5
		or b.id ilike $5)
	or $5 is null)
order by
	u.created_at desc;
end;

$function$
;
-- DROP FUNCTION public.get_student_data(int4);

create or replace
function public.get_student_data("STUDENTID" integer)
 returns table("Id" integer,
"Name" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"Type" character varying,
"ImageUrl" character varying,
"ExamTarget" text,
"IsDeleted" boolean,
"EmailVerified" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying,
"City" character varying,
"ExamDate" timestamp without time zone,
"IsSubscribed" boolean,
"SubscriptionID" character varying,
"SubscriptionEndTimeUTC" timestamp with time zone,
"PlanID" character varying,
"BranchID" character varying,
"BranchName" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    select
	u.id as "Id",
	u."name" as "Name",
	u.email as "Email",
	u.created_at as "CreatedAt",
	u.updated_at as "UpdatedAt",
	u.type as "Type",
	u.image_url as "ImageUrl",
	u.exam_target as "ExamTarget",
	u.is_deleted as "IsDeleted",
	u.is_email_verified as "EmailVerified",
	u.phone_number as "PhoneNumber",
	u.country_code as "CountryCode",
	u.city as "City",
	u.exam_date as "ExamDate",
	u.is_subscribed as "IsSubscribed",
	u.subscription_id as "SubscriptionID",
	((u.subscription_time + (s.days || ' days')::interval) at TIME zone 'UTC')::timestamptz as "SubscriptionEndTimeUTC",
	u.plan_id as "PlanID",
		u.branch_id as "BranchID",
		b.name as "BranchName"
from
	public.users u
left join 
        public.subscriptions s on
	u.subscription_id = s.id
left join public.branches b
		on
	u.branch_id = b.id
where
	u.id = $1;
end;

$function$
;
-- DROP FUNCTION public.get_student_from_trash_by_admin(int4, varchar, bool, varchar);

create or replace
function public.get_student_from_trash_by_admin("PORTALID" integer,
"NAME" character varying,
"SUBSCRIBED" boolean,
"TYPE" character varying)
 returns table("Id" integer,
"Email" character varying,
"Name" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"Type" character varying,
"IsSubscribed" boolean)
 language plpgsql
as $function$
	begin
		return query
		select
	id,
	email,
	"name",
	created_at,
	updated_at,
	type,
	is_subscribed
from
	public.users
where
	is_deleted = true
	and deleted_from_trash = false
	and portal_id = $1
	and ("name" ilike $2
		or $2 is null)
	and (is_subscribed = $3
		or $3 is null)
	and (type ilike $4
		or $4 is null);
end;

$function$
;
-- DROP FUNCTION public.get_test_categories_with_tests();

create or replace
function public.get_test_categories_with_tests()
 returns table("TestCategoryId" integer,
"CategoryName" character varying,
"Tests" jsonb)
 language plpgsql
as $function$
begin
    return QUERY
    select
	tc.id as "TestCategoryId",
	tc.category_name as "CategoryName",
	coalesce(
               (
	select
		jsonb_agg(
                   jsonb_build_object(
                       'TestId',
		t.id,
		'TestName',
		t.test_name,
		'IsAnswerFixed',
		t.is_answer_fixed,
		'BeginningTime',
		t.beginning_time,
		'TotalTime',
		t.total_time
                   )
	order by
		t.order_id asc,
		t.id asc
               )
	from
		public.test t
	where
		t.category_id = tc.id
		and t.id is not null
               ),
	'[]'::jsonb) as "Tests"
from
	public.test_categories tc
order by
	tc.order_id,
	tc.id;
end;

$function$
;
-- DROP FUNCTION public.get_test_question_note_of_user(int4, int4);

create or replace
function public.get_test_question_note_of_user("TESTQUESTIONID" integer,
"USERID" integer)
 returns table("Id" integer,
"Note" character varying,
"CreatedAt" timestamp without time zone)
 language plpgsql
as $function$
	begin
		return query
		select
	id ,
	note ,
	created_at
from
	public.test_question_notes tqn
where
	tqn.test_question_id = $1
	and tqn.user_id = $2
		;
end;

$function$
;
-- DROP FUNCTION public.get_test_questions_by_test_id(int4, int4, int4);

create or replace
function public.get_test_questions_by_test_id("TESTID" integer,
"PAGE" integer,
"PAGESIZE" integer)
 returns table("TestQuestionTableId" integer,
"QuestionId" integer,
"QuestionName" character varying,
"QuestionStatement" character varying)
 language plpgsql
as $function$
begin
		return query
		select
	tq.id,
	tq.question_id ,
	q.name ,
	q.statement
from
	public.test_questions tq
left join public.question q
		on
	tq.question_id = q.id
where
	tq.test_id = $1
limit $2 offset $3;
end;

$function$
;
-- DROP FUNCTION public.get_test_questions_by_test_name(varchar, int4, int4, int4);

create or replace
function public.get_test_questions_by_test_name("TESTNAME" character varying,
"PAGE" integer,
"PAGESIZE" integer,
"USERID" integer)
 returns json
 language plpgsql
as $function$
	declare 
		total_questions_ integer = 0;

result json;

begin
	select
	count(tq.id)
into
	total_questions_
from
	public.test_questions tq
left join public.test t
	on
	tq.test_id = t.id
where
	t.test_name = $1;

result := json_build_object(
        'total_questions',
total_questions_,
        'questions',
(
select
	json_agg(row_to_json(t))
from
	(
	select
		tq.id as "TestQuestionTableId",
		tq.question_id as "QuestionId",
		q.name as "QuestionName",
		q.statement as "QuestionStatement",
		COUNT(aq.id) as "TestAttemptedCount"
	from
		public.test_questions tq
	left join
                    public.question q on
		tq.question_id = q.id
	left join
                    public.attempted_questions aq on
		tq.id = aq.test_question_id
		and aq.user_id = $4
	left join 
                    public.test t on
		t.id = tq.test_id
	where
		t.name = $1
	group by
		tq.id,
		tq.question_id,
		q.name,
		q.statement
	limit $3 offset $2
            ) t
        )
    );

return result;
end;

$function$
;
-- DROP FUNCTION public.get_test_questions_of_user_by_test_id(int4, int4, int4, int4, varchar);

create or replace
function public.get_test_questions_of_user_by_test_id("TESTID" integer,
"PAGE" integer,
"PAGESIZE" integer,
"USERID" integer,
"SearchName" character varying)
 returns table("TestQuestionTableId" integer,
"QuestionId" integer,
"QuestionName" character varying,
"QuestionStatement" character varying,
"TestAttemptedCount" integer)
 language plpgsql
as $function$
begin
    return QUERY
	select
	    tq.id,
	    tq.question_id,
	    q.name,
	    q.statement,
	    cast(COUNT(aq.id) as integer) as attempted_count
	--	    ,
	--	    CONCAT('[', COALESCE(ARRAY_TO_STRING(ARRAY_AGG(aq.id ORDER BY aq.created_at desc), ','), ''), ']') AS attempted_ids
from
	    public.test_questions tq
left join
	    public.question q on
	tq.question_id = q.id
left join
	    public.attempted_questions aq on
	tq.id = aq.test_question_id
	and aq.user_id = $4
where
	    tq.test_id = $1
	and ($5 is null
		or q.name ilike '%' || $5 || '%')
group by
	    tq.id,
	    tq.question_id,
	    q.name,
	    q.statement
limit $2 offset $3;
end;

$function$
;
-- DROP FUNCTION public.get_test_questions_of_user_by_test_name(varchar, int4, int4, int4, bool, varchar, varchar, bool, bool);

create or replace
function public.get_test_questions_of_user_by_test_name("TESTNAME" character varying,
"PAGE" integer,
"PAGESIZE" integer,
"USERID" integer,
"ISPRECORE" boolean,
"SEARCHNAME" character varying,
"ORDERBY" character varying,
"HIGHFREQUENCY" boolean,
"BOOKMARKED" boolean)
 returns json
 language plpgsql
as $function$
declare 
    total_questions_ integer := 0;

result json;

begin
-- Count total questions
    select
	count(tq.id)
into
	total_questions_
from
	public.test_questions tq
left join public.test t on
	tq.test_id = t.id
where
	t.test_name = $1;
-- Fetch test questions and aggregate into JSON
    with test_questions_cte as (
select
	json_build_object(
            'TestQuestionTableId',
	tq.id,
	'QuestionId',
	tq.question_id,
	'QuestionName',
	q.name,
	'TestAttemptedCount',
	cast((
	select
		count(aq.id)
	from
		public.attempted_questions aq
	where
		tq.id = aq.test_question_id
		and aq.user_id = $4
		and aq.is_ptecore = $5
    ) as integer),
	'BeginningTime',
	t.beginning_time,
	'TotalTime',
	t.total_time,
	'IsBookMarked',
	exists (
	select
		1
	from
		public.bookmarks b
	where
		tq.id = b.test_question_id
		and b.user_id = $4),
	'AppearedCount',
	cast(COUNT(apq.id) as integer),
	'BookMarkedId',
	b.id
        ) as json_obj
from
	public.test_questions tq
left join public.question q on
	tq.question_id = q.id
left join public.attempted_questions aq on
	tq.id = aq.test_question_id
	and aq.user_id = $4
	and aq.is_ptecore = $5
left join public.test t on
	t.test_name = $1
left join public.appeared_questions apq on
	q.id = apq.question_id
left join public.bookmarks b on
	tq.id = b.test_question_id
	and b.user_id = $4
where
	tq.test_id = t.id
	and ($6 is null
		or q.name ilike '%' || $6 || '%'
		or q.id::character varying ilike '%' || $6 || '%')
	and (
        $9 is null
		or 
        $9 is false
		or ($9 = true
			and exists (
			select
				1
			from
				public.bookmarks b
			where
				tq.id = b.test_question_id
				and b.user_id = $4
        ))
    )
group by
	tq.id,
	tq.question_id,
	q.name,
	t.beginning_time,
	t.total_time,
	b.id,
	q.id
order by 
	case
		when $7 = 'asc' then q.id
		else null
	end asc,
	case
		when $7 = 'desc' then q.id
		else null
	end desc,
	case
		when $8 then cast(COUNT(apq.id) as integer)
		else null
	end desc
limit $2 offset $3
    )
-- Combine results into a single JSON object
    select
	json_build_object(
        'total_questions',
	total_questions_,
	'test_questions',
	json_agg(json_obj)
    )
    into
	result
from
	test_questions_cte;

return result;
end;

$function$
;
-- DROP FUNCTION public.get_test_questions_of_user_by_test_name(varchar, int4, int4, int4, bool, varchar, varchar, bool, bool, varchar, bool, bool, varchar);

create or replace
function public.get_test_questions_of_user_by_test_name("TESTNAME" character varying,
"PAGE" integer,
"PAGESIZE" integer,
"USERID" integer,
"ISPRECORE" boolean,
"SEARCHNAME" character varying,
"ORDERBY" character varying,
"HIGHFREQUENCY" boolean,
"BOOKMARKED" boolean,
"ISPRACTISED" character varying,
"EASY" boolean,
"PREDICTION" boolean,
"DIFFICULTY" character varying)
 returns json
 language plpgsql
as $function$
declare 
    total_questions_ integer := 0;

result json;

begin
-- Count total questions
    select
	count(tq.id)
    into
	total_questions_
from
	public.test_questions tq
left join public.test t on
	tq.test_id = t.id
where
	t.test_name = $1;
-- Fetch test questions and aggregate into JSON
    with test_questions_cte as (
select
	json_build_object(
    'TestQuestionTableId',
	tq.id,
	'QuestionId',
	tq.question_id,
	'QuestionName',
	q.name,
	'TestAttemptedCount',
	cast((
	select
		count(aq.id)
	from
		public.attempted_questions aq
	where
		tq.id = aq.test_question_id
		and aq.user_id = $4
		and aq.is_ptecore = $5
                ) as integer),
	'BeginningTime',
	t.beginning_time,
	'TotalTime',
	t.total_time,
	'IsBookMarked',
	exists (
	select
		1
	from
		public.bookmarks b
	where
		tq.id = b.test_question_id
		and b.user_id = $4
                ),
	'AppearedCount',
	cast(COUNT(apq.id) as integer),
	'BookMarkedId',
	b.id,
	'Prediction',
	q.prediction,
	'CreatedAt',
	q.created_at,
	'UpdatedAt',
	q.updated_at,
	'Difficuty',
	q.difficulty
            ) as json_obj
from
	public.test_questions tq
left join public.question q on
	tq.question_id = q.id
left join public.attempted_questions aq on
	tq.id = aq.test_question_id
	and aq.user_id = $4
	and aq.is_ptecore = $5
left join public.test t on
	t.test_name = $1
left join public.appeared_questions apq on
	q.id = apq.question_id
left join public.bookmarks b on
	tq.id = b.test_question_id
	and b.user_id = $4
left join public.options op on
	q.id = op.question_id
where
	tq.test_id = t.id
	and ($6 is null
		or q.name ilike '%' || $6 || '%'
		or q.id::character varying ilike '%' || $6 || '%')
	and ($9 is null
		or $9 is false
		or ($9 = true
			and exists (
			select
				1
			from
				public.bookmarks b
			where
				tq.id = b.test_question_id
				and b.user_id = $4)))
	and ($10 is null
		or ($10 = 'practiced'
			and exists (
			select
				1
			from
				public.attempted_questions aq
			where
				tq.id = aq.test_question_id
				and aq.user_id = $4
				and aq.is_ptecore = $5))
		or ($10 = 'not-practiced'
			and not exists (
			select
				1
			from
				public.attempted_questions aq
			where
				tq.id = aq.test_question_id
				and aq.user_id = $4
				and aq.is_ptecore = $5)))
	and ($12 is null
		or q.prediction = $12)
	and ($13 is null
		or q.difficulty = $13)
group by
	tq.id,
	tq.question_id,
	q.name,
	t.beginning_time,
	t.total_time,
	b.id,
	q.id,
	q.created_at,
	q.updated_at ,
	op.answer_names,
	q.difficulty
order by 
			case
			    when $11 = true
		and q.statement is not null then LENGTH(q.statement)
		when $11 = true
			and q.statement is null then 
			        LENGTH(
			            (string_to_array(
			                replace(replace(op.answer_names,
			'[',
			''),
			']',
			''), 
			                ','
			            ))[1]
			-- Access the first element
			        )
			else null
		end asc,
			case
			    when $11 = false
				and q.statement is not null then LENGTH(q.statement)
				when $11 = false
					and q.statement is null then 
			        LENGTH(
			            (string_to_array(
			                replace(replace(op.answer_names,
					'[',
					''),
					']',
					''),
					','
			            ))[1]
					-- Access the first element
			        )
					else null
				end desc,
				case
					when $7 = 'asc' then q.id
					else null
				end asc,
				case
					when $7 = 'desc' then q.id
					else null
				end desc,
				case
					when $8 then cast(COUNT(apq.id) as integer)
					else null
				end desc
			limit $2 offset $3
    )
-- Combine results into a single JSON object
    select
	json_build_object(
            'total_questions',
	total_questions_,
	'test_questions',
	json_agg(json_obj)
        )
    into
	result
from
	test_questions_cte;

return result;
end;

$function$
;
-- DROP FUNCTION public.get_test_questions_of_user_by_test_name_for_admin(varchar, int4, int4, bool, varchar, varchar, bool, bool);

create or replace
function public.get_test_questions_of_user_by_test_name_for_admin("TESTNAME" character varying,
"PAGE" integer,
"PAGESIZE" integer,
"ISPRECORE" boolean,
"SEARCHNAME" character varying,
"ORDERBY" character varying,
"HIGHFREQUENCY" boolean,
"EASY" boolean)
 returns json
 language plpgsql
as $function$
declare 
    total_questions_ integer := 0;

result json;

begin
-- Count total questions
    select
	count(tq.id)
into
	total_questions_
from
	public.test_questions tq
left join public.test t on
	tq.test_id = t.id
where
	t.test_name = $1;
-- Fetch test questions and aggregate into JSON
    with test_questions_cte as (
select
	json_build_object(
		'TestQuestionTableId',
	tq.id,
		'QuestionId',
	tq.question_id,
		'QuestionName',
	q.name,
		'BeginningTime',
	t.beginning_time,
		'TotalTime',
	t.total_time,
		'TestId',
	q.test_id,
		'Prediction',
	q.prediction,
		'Difficulty', 
	q.difficulty
	) as json_obj
from
	public.test_questions tq
left join public.question q on
	tq.question_id = q.id
left join public.test t on
	t.test_name = $1
left join public.appeared_questions apq on
	q.id = apq.question_id
left join public.options op on
	q.id = op.question_id
where
	tq.test_id = t.id
	and ($5 is null
		or q.name ilike '%' || $5 || '%'
		or q.id::character varying ilike '%' || $5 || '%')
group by
	tq.id,
	tq.question_id,
	q.name,
	t.beginning_time,
	t.total_time,
	q.id,
	op.answer_names,
	q.difficulty
order by 
	case
		when $6 = 'asc' then q.id
		else null
	end asc,
	case
		when $6 = 'desc' then q.id
		else null
	end desc,
	case
		when $7 then cast(COUNT(apq.id) as integer)
		else null
	end desc,
	case
		when $8 = true
			and q.statement is not null then LENGTH(q.statement)
			when $8 = true
				and q.statement is null then 
	        LENGTH(
	            (string_to_array(
	                replace(replace(op.answer_names,
				'[',
				''),
				']',
				''),
				','
	            ))[1]
				-- Access the first element
	        )
				else null
			end asc,
			case
				when $8 = false
					and q.statement is not null then LENGTH(q.statement)
					when $8 = false
						and q.statement is null then 
	        LENGTH(
	            (string_to_array(
	                replace(replace(op.answer_names,
						'[',
						''),
						']',
						''),
						','
	            ))[1]
						-- Access the first element
	        )
						else null
					end desc
				limit $2 offset $3
    )
-- Combine results into a single JSON object
    select
	json_build_object(
    'total_questions',
	total_questions_,
	'test_questions',
	json_agg(json_obj)
    )
    into
	result
from
	test_questions_cte;

return result;
end;

$function$
;
-- DROP FUNCTION public.get_transaction_details();

create or replace
function public.get_transaction_details()
 returns table("TransactionDetails" text)
 language plpgsql
as $function$
	begin
		return query
		select
	transaction_details
from
	public.admins
where
	id = 1;
end;

$function$
;
-- DROP FUNCTION public.get_user_exam_date(int4);

create or replace
function public.get_user_exam_date("USERID" integer)
 returns table("ExamDate" timestamp without time zone,
"ExamTarget" text,
"ExamCreatedDate" timestamp without time zone,
"AttemptedTestCounts" json[])
 language plpgsql
as $function$
declare
    examDate_ timestamp;

examTarget_ text;

exam_date_created_at_ timestamp;

attemptedCounts_ json[];

begin
-- Get exam date and target
    select
	exam_date,
	exam_target,
	exam_date_created_at
    into
	examDate_,
	examTarget_,
	exam_date_created_at_
from
	public.users
where
	id = $1;
-- Get attempted test counts and store in JSON array
    select
	array_agg(row_to_json(test_counts))
into
	attemptedCounts_
from
	(
	select
		t.test_name,
		coalesce(COUNT(distinct aq.test_question_id),
		0) as count
	from
		public.test t
	left join public.test_questions tq on
		t.id = tq.test_id
	left join public.attempted_questions aq 
            on
		tq.id = aq.test_question_id
		and aq.user_id = $1
		and DATE_TRUNC('day',
		aq.created_at at TIME zone 'UTC') = DATE_TRUNC('day',
		NOW() at TIME zone 'UTC')
			and aq.created_at > (
			select
				u.exam_date_created_at
			from
				public.users u
			where
				u.id = $1)
		group by
			t.test_name
    ) as test_counts;
-- Return the results
    return QUERY
    select
	examDate_,
	examTarget_,
	exam_date_created_at_,
	attemptedCounts_;
end;

$function$
;
-- DROP FUNCTION public.get_user_stored_analysis(int4, bool);

create or replace
function public.get_user_stored_analysis("USERID" integer,
"PTE" boolean)
 returns table("Analysis" jsonb,
"LastUpdated" timestamp without time zone)
 language plpgsql
as $function$
	begin
		if ($2 = true) then
			return query
			select 
			pte_stats,
			last_updated_pte
from
	public.users
where
	id = $1;
else
			return query
			select
			academic_stats,
			last_updated_acadamic
from
	public.users
where
	id = $1;
end if;
end;

$function$
;
-- DROP FUNCTION public.get_user_transactions(int4, varchar);

create or replace
function public.get_user_transactions("USERID" integer,
"REFERENCENUMBER" character varying)
 returns table("Id" character varying,
"UserId" integer,
"SubscriptionId" character varying,
"SubscriptionName" character varying,
"Status" character varying,
"RequestPayload" character varying,
"ResponsePayload" character varying,
"BankAlfalahSubscriptionId" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"PromocodeId" character varying,
"ImageUrl" character varying,
"IsApproved" boolean,
"Country" character varying,
"Currency" character varying,
"Phone" character varying,
"Email" character varying,
"PortalId" integer,
"OrderId" character varying,
"TransactionReferenceNumber" character varying,
"TransactionId" character varying,
"TransactionAmount" character varying,
"TransactionDescription" character varying,
"TransactionStatus" character varying,
"ReferenceNumber" character varying,
"Location" character varying,
"BoughtByAndReason" text)
 language plpgsql
as $function$
begin
    return QUERY
    select
	ut.id as "Id",
	ut.user_id as "UserId",
	ut.subscription_id as "SubscriptionId",
	s."name" as "SubscriptionName",
	ut.status as "Status",
	ut.request_payload as "RequestPayload",
	ut.response_payload as "ResponsePayload",
	ut.bank_alfalah_subscription_id as "BankAlfalahSubscriptionId",
	ut.created_at as "CreatedAt",
	ut.updated_at as "UpdatedAt",
	ut.promocode_id as "PromocodeId",
	ut.image_url as "ImageUrl",
	ut.is_approved as "IsApproved",
	ut.country as "Country",
	ut.currency as "Currency",
	ut.phone as "Phone",
	ut.email as "Email",
	ut.portal_id as "PortalId",
	ut.order_id as "OrderId",
	ut.transaction_reference_number as "TransactionReferenceNumber",
	ut.transaction_id as "TransactionId",
	ut.transaction_amount as "TransactionAmount",
	ut.transaction_description as "TransactionDescription",
	ut.transaction_status as "TransactionStatus",
	ut.reference_number as "ReferenceNumber",
	ut."location" as "Location",
	ut.bought_by_and_reason as "BoughtByAndReason"
from
	public.user_transactions ut
left join
        public.subscriptions s
    on
	ut.subscription_id = s.id
where
	ut.user_id = "USERID"
	and (ut.reference_number ilike "REFERENCENUMBER"
		or "REFERENCENUMBER" is null)
order by
	ut.created_at;
end;

$function$
;
-- DROP FUNCTION public.get_whitelabel_transactions_account_usage_all(int4);

create or replace
function public.get_whitelabel_transactions_account_usage_all("PORTALID" integer)
 returns table("TransactionId" character varying,
"PlanId" character varying,
"PlanName" character varying,
"PlanDays" character varying,
"AdminName" character varying,
"AdminEmail" character varying,
"CreatedAt" timestamp without time zone,
"UserId" integer,
"UserName" character varying,
"Manual" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    select
	wta.id as "TransactionId",
	wta.plan_id as "PlanId",
	p.name as "PlanName",
	p.days as "PlanDays",
	a.name as "AdminName",
	a.email as "AdminEmail",
	wta.created_at as "CreatedAt",
	wta.user_id as "UserId",
	u.name as "UserName",
	wta.manual as "Manual"
from
	public.whitelabel_transactions_account_usage wta
left join public.admins a on
	wta.admin_id = a.id
left join public.plans_for_whitelabels p on
	wta.plan_id = p.id
left join public.users u on
	wta.user_id = u.id
where
	($1 = 1)
	-- If PORTALID is 1, show all transactions
	or (a.portal_id = $1);
-- Otherwise, show transactions for the specific portal
end;

$function$
;
-- DROP FUNCTION public.get_whitelabel_transactions_by_user_id(int4);

create or replace
function public.get_whitelabel_transactions_by_user_id("USERID" integer)
 returns table("TransactionId" character varying,
"PlanId" character varying,
"PlanName" character varying,
"PlanDays" character varying,
"AdminName" character varying,
"AdminEmail" character varying,
"CreatedAt" timestamp without time zone,
"Manual" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    select
	wta.id as "TransactionId",
	wta.plan_id as "PlanId",
	p.name as "PlanName",
	p.days as "PlanDays",
	a.name as "AdminName",
	a.email as "AdminEmail",
	wta.created_at as "CreatedAt",
		wta.manual as "Manual"
from
	public.whitelabel_transactions_account_usage wta
left join public.admins a on
	wta.admin_id = a.id
left join public.plans_for_whitelabels p on
	wta.plan_id = p.id
where
	wta.user_id = $1;
end;

$function$
;
-- DROP FUNCTION public.login_admin(varchar, varchar);

create or replace
function public.login_admin("EMAIL" character varying,
"PASSWORD" character varying)
 returns table("AdminId" integer,
"AdminName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"PortalId" integer,
"Role" character varying,
"Permissions" jsonb,
"CountryId" character varying,
"PortalLink" character varying,
"BranchName" character varying)
 language plpgsql
as $function$
begin
    return QUERY
    with permission_details as (
select
	p.id as permission_id,
	p."name" as permission_name,
	mt.main_type_name,
	st.sub_type_name
from
	public.permissions p
join public.permission_main_type mt 
            on
	p.main_type = mt.id
join public.permission_sub_types st 
            on
	p.sub_type = st.id
where
	p.id in (
	select
		permission_id
	from
		public.permissions_admin
	where
		admin_id = (
		select
			id
		from
			public.admins
		where
			email = $1
			and pgp_sym_decrypt("password"::bytea,
			'encryptingpassword')::character varying = $2
                )
            )
    ),
    aggregated_permissions as (
select
	main_type_name,
	sub_type_name,
	jsonb_agg(
                jsonb_build_object(
                    'PermissionId',
	permission_id,
	'PermissionName',
	permission_name
                )
            ) as permissions
from
	permission_details
group by
	main_type_name,
	sub_type_name
    ),
    main_type_aggregated as (
select
	main_type_name,
	jsonb_object_agg(
                sub_type_name,
	permissions
            ) as sub_type_permissions
from
	aggregated_permissions
group by
	main_type_name
    ),
    permissions_array as (
select
	jsonb_build_object(
                main_type_name,
	sub_type_permissions
            ) as permission_object
from
	main_type_aggregated
    )
    select
	a.id as "AdminId",
	a."name" as "AdminName",
	a.email as "Email",
	a.created_at as "CreatedAt",
	a.portal_id as "PortalId",
	a.role as "Role",
	coalesce(
            (
	select
		jsonb_agg(permission_object)
	from
		permissions_array
            ),
	'[]'::jsonb
        ) as "Permissions",
	pt.country_id as "CountryId",
	pt.portal_link as "PortalLink",
	b."name" as "BranchName"
from
	public.admins a
left join public.portal pt 
        on
	a.portal_id = pt.id
left join public.branches b
        on
	a.branch_id = b.id
where
	a.email = $1
	and pgp_sym_decrypt(a."password"::bytea,
	'encryptingpassword')::character varying = $2;
end;

$function$
;
-- DROP FUNCTION public.login_admin(varchar, varchar, int4);

create or replace
function public.login_admin("EMAIL" character varying,
"PASSWORD" character varying,
"PORTALID" integer)
 returns table("AdminId" integer,
"AdminName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"Permissions" jsonb,
"CountryId" character varying)
 language plpgsql
as $function$
    begin
        return QUERY
        with perms as (
select
	a.id as admin_id,
	a."name" as admin_name,
	a.email,
	a.created_at,
	mt.main_type_name,
	st.sub_type_name,
	p.id as permission_id,
	p."name" as permission_name,
	p.country_id
from
	public.admins a
left join 
                public.permissions_admin pa on
	a.id = pa.admin_id
left join 
                public.permissions p on
	pa.permission_id = p.id
left join 
                public.permission_main_type mt on
	p.main_type = mt.id
left join 
                public.permission_sub_types st on
	p.sub_type = st.id
where
	a.email = $1
	and pgp_sym_decrypt(a."password"::bytea,
	'encryptingpassword')::character varying = $2
		and a.portal_id = $3
        )
        select
	admin_id as "AdminId",
	admin_name as "AdminName",
	email as "Email",
	created_at as "CreatedAt",
	coalesce(
                jsonb_object_agg(
                    main_type_name,
	jsonb_object_agg(
                        sub_type_name,
	jsonb_agg(
                            jsonb_build_object(
                                'PermissionId',
	permission_id,
	'PermissionName',
	permission_name
                            )
                        )
                    )
                ) filter (
where
	permission_id is not null),
	'{}'::jsonb
            ) as "Permissions"
from
	perms
group by
	admin_id,
	admin_name,
	email,
	created_at;
end;

$function$
;
-- DROP FUNCTION public.login_user(varchar, varchar);

create or replace
function public.login_user("EMAIL" character varying,
"PASSWORD" character varying)
 returns table("UserId" integer,
"UserName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"EmailVerified" boolean,
"IsDeleted" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying,
"City" character varying,
"ImageUrl" character varying,
"ExamDate" timestamp without time zone,
"EXAMTARGET" text,
"IsSubscribed" boolean)
 language plpgsql
as $function$
	begin
		return query
		select
	id,
	"name" ,
	email,
	created_at,
	is_email_verified,
	is_deleted ,
	phone_number ,
	country_code ,
	city ,
	image_url,
	exam_date,
	exam_target,
	is_subscribed
from
	public.users
where
	email = $1
	and pgp_sym_decrypt("password"::bytea,
	'encryptingpassword')::character varying = $2
	and is_deleted = false;
end;

$function$
;
-- DROP FUNCTION public.login_user(varchar, varchar, int4, varchar, timestamptz);

create or replace
function public.login_user("EMAIL" character varying,
"PASSWORD" character varying,
"PORTALID" integer,
"SESSIONID" character varying,
"SESSIONEXPIRY" timestamp with time zone)
 returns table("UserId" integer,
"UserName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"EmailVerified" boolean,
"IsDeleted" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying,
"City" character varying,
"ImageUrl" character varying,
"ExamDate" timestamp without time zone,
"EXAMTARGET" text,
"IsSubscribed" boolean,
"SubscriptionID" character varying,
"SubscriptionEndTimeUTC" timestamp with time zone,
"PlanID" character varying,
"PlanName" character varying,
"PortalID" integer)
 language plpgsql
as $function$
declare
    userId_ integer;

userName_ character varying;

email_ character varying;

createdAt_ timestamp without time zone;

emailVerified_ boolean;

isDeleted_ boolean;

phoneNumber_ character varying;

countryCode_ character varying;

city_ character varying;

imageUrl_ character varying;

examDate_ timestamp without time zone;

examTarget_ text;

isSubscribed_ boolean;

subscriptionId_ character varying;

subscriptionEndTimeUTC_ timestamp with time zone;

plan_id_ character varying;

subscription_time_ timestamptz;

plan_name_ character varying;

portal_id_ integer;

begin
-- Attempt to retrieve the user record
    select
	u.id,
	u."name",
	u.email,
	u.created_at,
	u.is_email_verified,
	u.is_deleted,
	u.phone_number,
	u.country_code,
	u.city,
	u.image_url,
	u.exam_date,
	u.exam_target,
	u.is_subscribed,
	u.subscription_id,
	((u.subscription_time + (s.days || ' days')::interval) at TIME zone 'UTC')::timestamptz,
	u.plan_id,
	u.subscription_time,
	pfw.plan,
	u.portal_id
    into
	userId_,
	userName_,
	email_,
	createdAt_,
	emailVerified_,
	isDeleted_,
	phoneNumber_,
	countryCode_,
	city_,
	imageUrl_,
	examDate_,
	examTarget_,
	isSubscribed_,
	subscriptionId_,
	subscriptionEndTimeUTC_,
	plan_id_,
	subscription_time_,
	plan_name_,
	portal_id_
from
	public.users u
left join public.subscriptions s on
	u.subscription_id = s.id
left join public.plans_for_whitelabels pfw
	on
	u.plan_id = pfw.id
where
	u.email = $1
	and pgp_sym_decrypt(u."password"::bytea,
	'encryptingpassword')::character varying = $2
	and u.portal_id = $3
	and u.is_deleted = false;
-- If a record is found, update session details
    if found then
-- Update the user's session ID and session expiry
        update
	public.users
set
	sessionid = $4,
	session_expiry = $5
where
	id = userId_;

if subscriptionEndTimeUTC_ is null
and plan_id_ is not null then
        select
	((subscription_time_ + (p.days || ' days')::interval) at TIME zone 'UTC')::timestamptz
        into
	subscriptionEndTimeUTC_
from
	plans_for_whitelabels p
where
	p.id = plan_id_;
end if;
-- Return the individual variables

return QUERY
select
	userId_ as "UserId",
	userName_ as "UserName",
	email_ as "Email",
	createdAt_ as "CreatedAt",
	emailVerified_ as "EmailVerified",
	isDeleted_ as "IsDeleted",
	phoneNumber_ as "PhoneNumber",
	countryCode_ as "CountryCode",
	city_ as "City",
	imageUrl_ as "ImageUrl",
	examDate_ as "ExamDate",
	examTarget_ as "EXAMTARGET",
	isSubscribed_ as "IsSubscribed",
	subscriptionId_ as "SubscriptionID",
	subscriptionEndTimeUTC_ as "SubscriptionEndTimeUTC",
	plan_id_ as "PlanID",
	plan_name_ as "PlanName",
	portal_id_ as "PortalID"
    ;
end if;

select
	u.portal_id,
	'u-s-e-r-n-a-m-e-f-o-u-n-d-i-n-o-t-h-e-r-p-o-r-t-a-l',
	p.portal_link
    into
	userId_,
	userName_,
	email_
from
	public.users u
left join public.portal p
on
	u.portal_id = p.id
where
	u.email = $1
	and pgp_sym_decrypt(u."password"::bytea,
	'encryptingpassword')::character varying = $2
	and u.is_deleted = false;

if found then 
	return QUERY
	select
		userId_ as "UserId",
		userName_ as "UserName",
	email_ as "Email",
	null::timestamp without time zone as "CreatedAt",
	null::boolean as "EmailVerified",
	null::boolean as "IsDeleted",
	null::character varying as "PhoneNumber",
	null::character varying as "CountryCode",
	null::character varying as "City",
	null::character varying as "ImageUrl",
	null::timestamp without time zone as "ExamDate",
	null::text as "EXAMTARGET",
	null::boolean as "IsSubscribed",
	null::character varying as "SubscriptionID",
	null::timestamp with time zone as "SubscriptionEndTimeUTC",
	null::character varying as "PlanID",
		null::character varying as "PlanName",
		null::integer as "PortalID";
end if;

return query
select 
		null::integer as "UserId",
		null::character varying as "UserName",
	null::character varying as "Email",
	null::timestamp without time zone as "CreatedAt",
	null::boolean as "EmailVerified",
	null::boolean as "IsDeleted",
	null::character varying as "PhoneNumber",
	null::character varying as "CountryCode",
	null::character varying as "City",
	null::character varying as "ImageUrl",
	null::timestamp without time zone as "ExamDate",
	null::text as "EXAMTARGET",
	null::boolean as "IsSubscribed",
	null::character varying as "SubscriptionID",
	null::timestamp with time zone as "SubscriptionEndTimeUTC",
	null::character varying as "PlanID",
		null::character varying as "PlanName",
		null::integer as "PortalID";
end;

$function$
;
-- DROP FUNCTION public.logout_user_by_admin(int4);

create or replace
function public.logout_user_by_admin("USERID" integer)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
   		update
	public.users
set
	session_expiry = null,
		sessionid = null
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.reactivate_promocode(varchar, int4, timestamp);

create or replace
function public.reactivate_promocode("PROMOCODEID" character varying,
"COUNT" integer,
"EXPIRY" timestamp without time zone)
 returns boolean
 language plpgsql
as $function$
declare
	adjusted_count integer;

rows_updated integer = 0;

begin
    if $2 is null then
	        adjusted_count := 0;
else
	        adjusted_count := $2;
end if;

update
	public.promo_codes
set
	active = true,
	count = adjusted_count,
	expiry_date = $3
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.remove_student_from_trash_by_admin(int4);

create or replace
function public.remove_student_from_trash_by_admin("USERID" integer)
 returns boolean
 language plpgsql
as $function$
declare
    rows_deleted integer = 0;

begin
    delete
from
	public.users
where
	id = $1;

get diagnostics rows_deleted = ROW_COUNT;

return rows_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.reset_mock_attempts_of_user(int4);

create or replace
function public.reset_mock_attempts_of_user("MOCKTESTATTEMPTID" integer)
 returns boolean
 language plpgsql
as $function$
	declare
    row_deleted integer := 0;

begin
		delete
from
	public.mock_test_attempts
where
	id = $1;

get diagnostics row_deleted = ROW_COUNT;

return row_deleted > 0;
end;

$function$
;
-- DROP FUNCTION public.reset_password(varchar, varchar);

create or replace
function public.reset_password("EMAIL" character varying,
"PASSWORD" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.users
set
	"password" = pgp_sym_encrypt($2,
	'encryptingpassword',
	'compress-algo=1') ,
	updated_at = now()
where
	email = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.reset_practice_questions_of_user(int4, varchar);

create or replace
function public.reset_practice_questions_of_user("USERID" integer,
"TESTNAME" character varying)
 returns boolean
 language plpgsql
as $function$
declare
    row_count INTEGER;

begin
    delete
from
	public.attempted_questions
where
	user_id = $1
	and test_question_id in (
	select
		id
	from
		public.test_questions
	where
		test_id = (
		select
			id
		from
			public.test
		where
			test_name = $2
        )
    );

get diagnostics row_count = ROW_COUNT;

return row_count > 0;
end;

$function$
;
-- DROP FUNCTION public.reset_user_free_tokens();

create or replace
function public.reset_user_free_tokens()
 returns void
 language plpgsql
as $function$
begin
-- Update all users to reset 'non_ai' and 'speaking' fields
    update
	public.users
set
	non_ai = 20,
	speaking = 5;
end;

$function$
;
-- DROP FUNCTION public.subtract_free_tokens(int4, varchar);

create or replace
function public.subtract_free_tokens("USERID" integer,
"TYPE" character varying)
 returns boolean
 language plpgsql
as $function$
    declare 
        rows_updated integer = 0;

begin
        if "TYPE" = 'non-ai' then
            update
	public.users
set
	non_ai = non_ai - 1
where
	id = "USERID";

elsif "TYPE" = 'speaking' then
            update
	public.users
set
	speaking = speaking - 1
where
	id = "USERID";

elsif "TYPE" = 'writing' then
            update
	public.users
set
	writing = writing - 1
where
	id = "USERID";
end if;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.superadmin_buy(int4, varchar, varchar, int4, text, varchar);

create or replace
function public.superadmin_buy("ADMINID" integer,
"PLANID" character varying,
"NOOFACCOUNTUSED" character varying,
"PORTALID" integer,
"BOUGHTBUYANDREASON" text,
"MANUAL" character varying)
 returns character varying
 language plpgsql
as $function$
    declare
        transaction_id_ varchar;

begin
        insert
	into
	public.whitelabel_transactions(
            admin_id,
	plan_id,
	no_of_accounts_purchased,
			portal_id,
			bought_by_and_reason,
			is_approved,
			reference_number,
			manual			
        )
values (
            $1,
            $2,
            $3,
            $4,
			$5,
			true,
			public.generate_random_string(24),
			$6
        )
        returning id
into
	transaction_id_;

perform public.add_white_label_total_account($4 ,
$2 ,
$3::integer,
transaction_id_);

return transaction_id_;
end;

$function$
;
-- DROP FUNCTION public.superadmin_buy_subscription_for_user(varchar, int4, text);

create or replace
function public.superadmin_buy_subscription_for_user("SUBSCRIPTIONID" character varying,
"USERID" integer,
"BOUGHTBUYANDREASON" text)
 returns character varying
 language plpgsql
as $function$
    declare
        transaction_id_ varchar;

begin
        insert
	into
	public.user_transactions(
            subscription_id,
	user_id,
			bought_by_and_reason,
			is_approved,
			reference_number
			
        )
values (
            $1,
            $2,
            $3,
			true,
			public.generate_random_string(24)
        )
        returning id
into
	transaction_id_;

update
	public.users
set 
			subscription_id = $1,
			is_subscribed = true
where
	id = $2;

return transaction_id_;
end;

$function$
;
-- DROP FUNCTION public.toggle_promo_code_status(varchar);

create or replace
function public.toggle_promo_code_status("PROMOCODEID" character varying)
 returns boolean
 language plpgsql
as $function$
declare
    rows_updated integer = 0;

begin
    update
	public.promo_codes
set
	active = not active
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.unsubscribe_user_on_timeend();

create or replace
function public.unsubscribe_user_on_timeend()
 returns void
 language plpgsql
as $function$
declare
    subscription_days INT;

subscription_start TIMESTAMPtz;

subscription_end TIMESTAMPtz;

current_time TIMESTAMPtz := NOW();

user_id INT;

begin
-- Loop through all users with active subscriptions
    for subscription_days,
subscription_start,
user_id in
        select
	s.days,
	(u.subscription_time)::timestamptz,
	u.id
from
	public.users u
join public.subscriptions s on
	u.subscription_id = s.id
where
	u.is_subscribed = true
    loop
	-- Calculate the subscription end time
	subscription_end := (subscription_start + (subscription_days * interval '1 day'))::timestamptz;
-- Check if the subscription has expired
        if (NOW())::timestamptz > subscription_end then
-- Update the user subscription details to indicate it has expired
            update
	public.users
set
	subscription_id = null,
	is_subscribed = false,
	subscription_time = null
where
	id = user_id;
end if;
end loop;

update
	public.users
set 
	plan_id = null,
	subscription_id = null,
	is_subscribed = false,
	subscription_time = null
where
	is_subscribed = false;
end;

$function$
;
-- DROP FUNCTION public.unsubscribe_user_on_timeend_for_plan();

create or replace
function public.unsubscribe_user_on_timeend_for_plan()
 returns void
 language plpgsql
as $function$
declare
    subscription_days INT;

subscription_start TIMESTAMPtz;

subscription_end TIMESTAMPtz;

current_time TIMESTAMPtz := NOW();

user_id INT;

begin
-- Loop through all users with active subscriptions
    for subscription_days,
subscription_start,
user_id in
        select
	pfw.days,
	(u.subscription_time)::timestamptz,
	u.id
from
	public.users u
join public.plans_for_whitelabels pfw on
	u.plan_id = pfw.id
where
	u.is_subscribed = true
    loop
	-- Calculate the subscription end time
	subscription_end := (subscription_start + (subscription_days * interval '1 day'))::timestamptz;
-- Check if the subscription has expired
        if (NOW())::timestamptz > subscription_end then
-- Update the user subscription details to indicate it has expired
            update
	public.users
set
	plan_id = null,
	is_subscribed = false,
	subscription_time = null
where
	id = user_id;
end if;
end loop;

update
	public.users
set 
	plan_id = null,
	subscription_id = null,
	is_subscribed = false,
	subscription_time = null
where
	is_subscribed = false;
end;

$function$
;
-- DROP FUNCTION public.update_admin(int4, varchar, varchar, _varchar, varchar);

create or replace
function public.update_admin("ID" integer,
"EMAIL" character varying,
"NAME" character varying,
"Permissions" character varying[],
"PASSWORD" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.admins
set
	email = $2 ,
	"name" = $3,
	password = case
		when $5 is not null then pgp_sym_encrypt($5,
		'encryptingpassword',
		'compress-algo=1')::character varying
		else password
	end,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

delete
from
	public.permissions_admin
where
	admin_id = $1;

for i in 1.. array_length($4, 1) loop
	insert
	into
	public.permissions_admin (admin_id,
	permission_id)
values ($1,
$4[i]);
end loop;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_admin_branch(int4, varchar);

create or replace
function public.update_admin_branch("ADMIN_ID" integer,
"BRANCH_ID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
    update
	public.admins
set
	branch_id = $2,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_country(varchar, varchar, varchar);

create or replace
function public.update_country("ID" character varying,
"NAME" character varying,
"CURRENCY" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
	update
	public.countries
set
	"name" = $2 ,
	currency = $3,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_help_center(varchar, varchar, varchar);

create or replace
function public.update_help_center("ID" character varying,
"NAME" character varying,
"LINK" character varying)
 returns boolean
 language plpgsql
as $function$
declare
    rows_updated integer := 0;

begin
    update
	public.help_center
set
	"name" = $2,
	link = $3,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_mock_test(int4, varchar, int4, bool, text);

create or replace
function public.update_mock_test("MOCKTESTID" integer,
"MOCKTESTNAME" character varying,
"TOTALTIME" integer,
"ISPTECORE" boolean,
"INDIVIDUALTIMES" text)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
    update
	public.mock_test
set
	name = $2,
	total_time = $3,
	updated_at = now(),
	core = $4,
	individual_times = $5
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_mock_test_attempt(int4, timestamp);

create or replace
function public.update_mock_test_attempt("MOCKTESTATTEMPTID" integer,
"ENDTIME" timestamp without time zone)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin  
		update
	public.mock_test_attempts
set 
		end_time = $2,
		total_marks_obtained = (
		    with main_query as (
	select
		            tc.category_name,
		            SUM(q.time_allowed) as total_time,
		            SUM(case when maq.mock_test_question_id is not null then q.time_allowed else 0 end) as attempted_time,
		            COUNT(q.id)::int4 as total_questions,
		            coalesce(SUM(case when maq.users_response is not null 
		                              and maq.users_response <> '{}' 
		                              and maq.users_response <> '"{}"' 
		                              and maq.users_response <> '' 
		                         then 1 else 0 end),
		0)::int4 as attempted_questions,
		            coalesce(SUM(case when maq.marks_obtained is not null 
		                              then (maq.marks_obtained::numeric / q.total_marks) * 100 
		                         else 0 end),
		0) as scores_percentage
	from
		            public.test_categories tc
	left join
		            public.test t on
		tc.id = t.category_id
	left join
		            public.question q on
		t.id = q.test_id
	left join
		            public.mock_test_questions mtq on
		q.id = mtq.question_id
	left join
		            public.mock_attempted_questions maq on
		mtq.id = maq.mock_test_question_id
		and maq.mock_test_attempt_id = $1
	group by
		            tc.category_name
		    ),
		    sub_query as (
	select
		            tc.category_name,
		            t.test_name,
		            COUNT(q.id)::int4 as total_questions,
		            coalesce(SUM(case when maq.users_response is not null 
		                              and maq.users_response <> '{}' 
		                              and maq.users_response <> '"{}"' 
		                              and maq.users_response <> '' 
		                         then 1 else 0 end),
		0)::int4 as attempted_questions,
		            coalesce(SUM(case when maq.marks_obtained is not null 
		                              then (maq.marks_obtained::numeric / q.total_marks) * 100 
		                         else 0 end),
		0) as scores_percentage,
		            SUM(q.time_allowed) as total_time_allowed,
		            coalesce(SUM(maq.time_taken),
		0) as total_time_taken
	from
		            public.test_categories tc
	left join
		            public.test t on
		tc.id = t.category_id
	left join
		            public.question q on
		t.id = q.test_id
	left join
		            public.mock_test_questions mtq on
		q.id = mtq.question_id
	left join
		            public.mock_attempted_questions maq on
		mtq.id = maq.mock_test_question_id
		and maq.mock_test_attempt_id = $1
	group by
		            t.test_name,
		            tc.category_name
		    ),
		    aggregated_sub_query as (
	select
		            category_name,
		            json_agg(
		                json_build_object(
		                    'test_name',
		test_name,
		                    'total_questions',
		total_questions,
		                    'attempted_questions',
		attempted_questions,
		                    'scores_percentage',
		scores_percentage,
		                    'total_time_allowed',
		total_time_allowed,
		                    'total_time_taken',
		total_time_taken
		                )
	order by
		test_name
		            ) as subcategories
	from
		            sub_query
	group by
		            category_name
		    )
	select
		json_agg(
		        json_build_object(
		            'category_name',
		main_query.category_name,
		            'total_time',
		main_query.total_time,
		            'attempted_time',
		main_query.attempted_time,
		            'total_questions',
		main_query.total_questions,
		            'attempted_questions',
		main_query.attempted_questions,
		            'scores_percentage',
		main_query.scores_percentage,
		            'subcategories',
		aggregated_sub_query.subcategories
		        )
		    ) as result
	from
		main_query
	left join aggregated_sub_query on
		main_query.category_name = aggregated_sub_query.category_name
		),
		updated_at = now(),
		status = 'completed'
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_option(int4, varchar, varchar, int4, varchar);

create or replace
function public.update_option("OPTIONID" integer,
"OPTIONNAMES" character varying,
"ANSWERNAMES" character varying,
"QUESTIONID" integer,
"OPTIONTEXT" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public."options"
set
	option_names = $2,
	answer_names = $3,
	question_id = $4,
	updated_at = now() ,
	option_text = $5
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_order_id_mock_test_questions(int4, int4);

create or replace
function public.update_order_id_mock_test_questions("CURRENTROWID" integer,
"SWAPROWID" integer)
 returns boolean
 language plpgsql
as $function$
declare
    temp_order_id integer;

rows_updated integer = 0;

begin
-- Retrieve the order_id for the row specified by CURRENTROWID
    select
	order_id
into
	temp_order_id
from
	public.mock_test_questions
where
	id = $1;
-- Update order_id for the row specified by CURRENTROWID with the order_id of the row specified by SWAPROWID
    update
	public.mock_test_questions
set
	order_id = (
	select
		order_id
	from
		public.mock_test_questions
	where
		id = $2)
where
	id = $1;
-- Update order_id for the row specified by SWAPROWID with the saved order_id value
    update
	public.mock_test_questions
set
	order_id = temp_order_id
where
	id = $2;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_order_id_mock_tests(int4, int4);

create or replace
function public.update_order_id_mock_tests("CURRENTROWID" integer,
"SWAPROWID" integer)
 returns boolean
 language plpgsql
as $function$
declare
    temp_order_id integer;

rows_updated integer = 0;

begin
-- Retrieve the order_id for the row specified by CURRENTROWID
    select
	order_id
into
	temp_order_id
from
	public.mock_test
where
	id = $1;
-- Update order_id for the row specified by CURRENTROWID with the order_id of the row specified by SWAPROWID
    update
	public.mock_test
set
	order_id = (
	select
		order_id
	from
		public.mock_test
	where
		id = $2)
where
	id = $1;
-- Update order_id for the row specified by SWAPROWID with the saved order_id value
    update
	public.mock_test
set
	order_id = temp_order_id
where
	id = $2;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_order_id_test_category(int4, int4);

create or replace
function public.update_order_id_test_category("CURRENTROWID" integer,
"SWAPROWID" integer)
 returns boolean
 language plpgsql
as $function$
declare
    temp_order_id integer;

rows_updated integer = 0;

begin
-- Retrieve the order_id for the row specified by CURRENTROWID
    select
	order_id
into
	temp_order_id
from
	public.test_categories
where
	id = $1;
-- Update order_id for the row specified by CURRENTROWID with the order_id of the row specified by SWAPROWID
    update
	public.test_categories
set
	order_id = (
	select
		order_id
	from
		public.test_categories
	where
		id = $2)
where
	id = $1;
-- Update order_id for the row specified by SWAPROWID with the saved order_id value
    update
	public.test_categories
set
	order_id = temp_order_id
where
	id = $2;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_order_id_test_questions(int4, int4);

create or replace
function public.update_order_id_test_questions("CURRENTROWID" integer,
"SWAPROWID" integer)
 returns boolean
 language plpgsql
as $function$
declare
    temp_order_id integer;

rows_updated integer = 0;

begin
-- Retrieve the order_id for the row specified by CURRENTROWID
    select
	order_id
into
	temp_order_id
from
	public.test_questions
where
	id = $1;
-- Update order_id for the row specified by CURRENTROWID with the order_id of the row specified by SWAPROWID
    update
	public.test_questions
set
	order_id = (
	select
		order_id
	from
		public.test_questions
	where
		id = $2)
where
	id = $1;
-- Update order_id for the row specified by SWAPROWID with the saved order_id value
    update
	public.test_questions
set
	order_id = temp_order_id
where
	id = $2;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_order_id_tests(int4, int4);

create or replace
function public.update_order_id_tests("CURRENTROWID" integer,
"SWAPROWID" integer)
 returns boolean
 language plpgsql
as $function$
declare
    temp_order_id integer;

rows_updated integer = 0;

begin
-- Retrieve the order_id for the row specified by CURRENTROWID
    select
	order_id
into
	temp_order_id
from
	public.test
where
	id = $1;
-- Update order_id for the row specified by CURRENTROWID with the order_id of the row specified by SWAPROWID
    update
	public.test
set
	order_id = (
	select
		order_id
	from
		public.test
	where
		id = $2)
where
	id = $1;
-- Update order_id for the row specified by SWAPROWID with the saved order_id value
    update
	public.test
set
	order_id = temp_order_id
where
	id = $2;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_portal(int4, varchar, varchar);

create or replace
function public.update_portal("PORTALID" integer,
"PORTALLINK" character varying,
"PORTALOWNERNAME" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.portal
set 
			portal_link = $2,
			portal_owner_name = $3,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_portal_configuration(int4, bool, bool, bool, bool, bool, bool);

create or replace
function public.update_portal_configuration("PORTALID" integer,
"STRATEGYVIDEOVISIBLE" boolean,
"TEMPLATEVISIBLE" boolean,
"GRAMMARVISIBLE" boolean,
"SELFSTRATEGYVIDEOVISIBLE" boolean,
"SELFTEMPLATEVISIBLE" boolean,
"SELFGRAMMARVISIBLE" boolean)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.portal
set 
			strategy_video_visible = $2,
			template_visible = $3,
			grammar_visible = $4,
			self_strategy_video_visible = $5,
			self_template_visible = $6,
			self_grammar_visible = $7,
			updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_portal_info(int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar);

create or replace
function public.update_portal_info("PORTALID" integer,
"FACEBOOKLINK" character varying,
"WHATSAPPLINK" character varying,
"TELEGRAMLINK" character varying,
"PHONENO" character varying,
"SUPPORTEMAIL" character varying,
"SUPPORTADDRESS" character varying,
"PORTALLOGO" character varying,
"PORTALFAVICON" character varying,
"LANDINGIMG" character varying,
"YOUTUBELINK" character varying,
"YOUTUBETHUMBNAIL" character varying,
"PORTALINFO" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		
		
		update
	public.portal
set
	updated_at = now(),
	facebook_link = $2,
	whatsapp_link = $3,
	telegram_link = $4,
	phone_no = $5,
	support_email = $6,
	support_address = $7,
	portal_logo = $8,
	portal_favicon = $9,
	landing_img = $10,
	youtube_url = $11,
	youtube_thumbnail = $12,
	portal_info = $13
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_prediction_file(int4, varchar, varchar, int4, bool);

create or replace
function public.update_prediction_file("FILEID" integer,
"NAME" character varying,
"FILEURL" character varying,
"PRIORITY" integer,
"CORE" boolean)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.prediction_file
set
	name = $2,
	file_url = $3,
	priority = $4,
	core = $5,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_price_in_bridge(varchar, varchar);

create or replace
function public.update_price_in_bridge("BRIDGETABLEID" character varying,
"PRICEPERACCOUNT" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
	update
	public.bridge_paln_subplans
set
	price_per_account = $2,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_question(int4, varchar, varchar, int4, varchar, varchar, varchar, int4, varchar, bool, varchar);

create or replace
function public.update_question("QUESTIONID" integer,
"QUESTIONNAME" character varying,
"QUESTIONSTATEMENT" character varying,
"TOTALMARKS" integer,
"AUDIOOBJECT" character varying,
"MAJORASPECTS" character varying,
"MINORASPECTS" character varying,
"TESTIDFORCATEGORY" integer,
"QUESTIONIMAGE" character varying,
"PREDICTION" boolean,
"DIFFICULTY" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
	    update
	public.question
set
	"name" = $2,
	"statement" = $3,
	total_marks = $4,
	updated_at = now(),
	audio_object = $5,
	major_aspects = $6,
	minor_aspects = $7,
	test_id = $8,
	question_image = $9,
	prediction = $10,
	difficulty = $11
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_question_prediction(int4);

create or replace
function public.update_question_prediction("QUESTIONID" integer)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.question
set
	prediction = not prediction,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_strategy_video(int4, varchar, varchar, varchar, varchar, int4, varchar, bool, varchar, int4);

create or replace
function public.update_strategy_video("ID" integer,
"TITLE" character varying,
"AUTHOR" character varying,
"YT_LINK" character varying,
"CATEGORY" character varying,
"PRIORITY" integer,
"LANGUAGE" character varying,
"CORE" boolean,
"THUMBNAIL" character varying,
"PORTALID" integer)
 returns boolean
 language plpgsql
as $function$
declare
	rows_updated integer := 0;

begin
	update
	public.strategy_video
set
		title = $2,
		author = $3,
		yt_link = $4,
		category = $5,
		priority = $6,
		"language" = $7,
		core = $8,
		thumbnail = $9,
		updated_at = now()
where
		id = $1
	and portal_id = $10;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_student(int4, varchar, varchar, varchar, varchar, varchar, varchar);

create or replace
function public.update_student("USERID" integer,
"NAME" character varying,
"IMAGEOFUSER" character varying,
"PASSWORD" character varying,
"TYPE" character varying,
"TARGET" character varying,
"NOTE" character varying)
 returns table("Updated" boolean,
"UserId" integer,
"UserName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"EmailVerified" boolean,
"IsDeleted" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying,
"City" character varying,
"ImageUrl" character varying,
"Type" character varying,
"Target" text,
"StudentNote" character varying)
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
	update
	public.users
set
	"name" = $2 ,
	updated_at = now() ,
	image_url = $3 ,
	password = case
		when $4 is not null then pgp_sym_encrypt($4,
		'encryptingpassword',
		'compress-algo=1')::character varying
		else password
	end,
	type = $5,
	exam_target = $6,
	student_note = $7
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return query 
		select
	rows_updated > 0 as Updated,
	id,
	"name" ,
	email,
	created_at,
	is_email_verified,
	is_deleted ,
	phone_number ,
	country_code ,
	city ,
	image_url,
	type,
	exam_target,
	student_note
from
	public.users
where
	id = $1;
end;

$function$
;
-- DROP FUNCTION public.update_student_branch(int4, varchar);

create or replace
function public.update_student_branch("STUDENT_ID" integer,
"BRANCH_ID" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
    update
	public.users
set
	branch_id = $2,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_subscription(varchar, varchar, varchar, int4, int4, varchar);

create or replace
function public.update_subscription("ID" character varying,
"NAME" character varying,
"DESC" character varying,
"PRICE_PKR" integer,
"DAYS" integer,
"DISCOUNT" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.subscriptions
set
	"name" = $2,
	"desc" = $3,
	price_pkr = $4,
	days = $5,
	discount = $6,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_template(int4, varchar, varchar, bool, int4);

create or replace
function public.update_template("TEMPLATEID" integer,
"NAME" character varying,
"PDFURL" character varying,
"ISTEMPLATE" boolean,
"PORTALID" integer)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.templates_and_grammar_pdfs
set
	name = $2,
	pdf_url = $3 ,
	is_template = $4 ,
	updated_at = now()
where
	id = $1
	and portal_id = $5;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_test(int4, int4, varchar, bool, int4, int4);

create or replace
function public.update_test("TESTID" integer,
"CATEGORYID" integer,
"TESTNAME" character varying,
"ISANSWERFIXED" boolean,
"BEGINNINGTIME" integer,
"TOTALTIME" integer)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
    update
	public.test
set
	category_id = $2,
	test_name = $3,
	is_answer_fixed = $4,
	beginning_time = $5,
	total_time = $6,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_test_category(int4, varchar);

create or replace
function public.update_test_category("TESTCATEGORYID" integer,
"CATEGORYNAME" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.test_categories
set
	category_name = $2,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_transaction_details_super_admin(text);

create or replace
function public.update_transaction_details_super_admin("TransactionDetails" text)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.admins
set
	transaction_details = $1
where
	id = 1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_user(int4, varchar, varchar, varchar, varchar, varchar);

create or replace
function public.update_user("ID" integer,
"NAME" character varying,
"PHONENUMBER" character varying,
"COUNTRYCODE" character varying,
"CITY" character varying,
"IMAGEOFUSER" character varying)
 returns table("Updated" boolean,
"UserId" integer,
"UserName" character varying,
"Email" character varying,
"CreatedAt" timestamp without time zone,
"EmailVerified" boolean,
"IsDeleted" boolean,
"PhoneNumber" character varying,
"CountryCode" character varying,
"City" character varying,
"ImageUrl" character varying)
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.users
set
	"name" = $2 ,
	phone_number = $3 ,
	country_code = $4 ,
	city = $5 ,
	image_url = $6
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return query 
		select
	rows_updated > 0 as Updated,
	id,
	"name" ,
	email,
	created_at,
	is_email_verified,
	is_deleted ,
	phone_number ,
	country_code ,
	city ,
	image_url
from
	public.users
where
	id = $1;
end;

$function$
;
-- DROP FUNCTION public.update_user_analysis_in_user(int4, jsonb, bool);

create or replace
function public.update_user_analysis_in_user("USERID" integer,
"ANALYSIS" jsonb,
"ISPTE" boolean)
 returns void
 language plpgsql
as $function$
	begin
		if ($3 = true) then
			update
	public.users
set
	pte_stats = $2,
			last_updated_pte = now()
where
	id = $1
			;
else 
			update
	public.users
set
	academic_stats = $2,
			last_updated_acadamic = now()
where
	id = $1
			;
end if;
end;

$function$
;
-- DROP FUNCTION public.update_user_exam_date(int4, timestamp, text);

create or replace
function public.update_user_exam_date("USERID" integer,
"EXAMDATE" timestamp without time zone,
"EXAMTARGET" text)
 returns table("ExamDate" timestamp without time zone,
"ExamTarget" text)
 language plpgsql
as $function$
	declare
		exam_date_ timestamp;

exam_target_ text;

begin
		update
	public.users
set
	exam_date = $2,
		exam_target = $3,
		exam_date_created_at = now()
where
	id = $1
        returning exam_date,
	exam_target
into
	exam_date_,
	exam_target_;

return query
        select
	exam_date_,
	exam_target_;
end;

$function$
;
-- DROP FUNCTION public.update_user_transaction(varchar, int4, int4, varchar, varchar, varchar, varchar);

create or replace
function public.update_user_transaction("ID" character varying,
"USER_ID" integer,
"SUBSCRIPTION_ID" integer,
"STATUS" character varying,
"REQUEST_PAYLOAD" character varying,
"RESPONSE_PAYLOAD" character varying,
"BANK_ALFALAH_SUBSCRIPTION_ID" character varying)
 returns boolean
 language plpgsql
as $function$
    declare
        rows_updated integer = 0;

begin
        update
	public.user_transactions
set
	user_id = $2,
	subscription_id = $3,
	status = $4,
	request_payload = $5,
	response_payload = $6,
	bank_alfalah_subscription_id = $7,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.update_vocab(int4, varchar);

create or replace
function public.update_vocab("ID" integer,
"TYPE" character varying)
 returns boolean
 language plpgsql
as $function$
	declare 
		rows_updated integer = 0;

begin
		update
	public.vocab_bank
set
	type = $2,
	updated_at = now()
where
	id = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.user_analysis(int4, bool);

create or replace
function public.user_analysis("USERID" integer,
"ISPTE" boolean)
 returns jsonb
 language plpgsql
as $function$
	declare 
	finalr jsonb;

begin
	select
	jsonb_object_agg(category_name,
	category_tests) as result
from
	(
	select
		category_name,
		jsonb_build_object(
	        'Tests',
		jsonb_object_agg(test_name,
		jsonb_build_object('TotalCount',
		count,
		'attemptedcount',
		attemptedcount )),
		'Total Questions',
		sum (count),
		'Total Attempted Questions',
		sum (attemptedcount)
	        ) as category_tests
	from
		(
		select
			tc.category_name,
			t.test_name,
			coalesce(COUNT(distinct tq.id),
			0) as count,
			coalesce(COUNT(distinct aq.test_question_id),
			0) as attemptedcount
		from
			test_questions tq
		left join
	            test t on
			tq.test_id = t.id
		left join
	            test_categories tc on
			t.category_id = tc.id
		left join 
	        	attempted_questions aq on
			tq.id = aq.test_question_id
			and aq.user_id = $1
		group by
			tc.category_name,
			t.test_name
	    ) as sub
	group by
		category_name
	) as resultr
into
	finalr;

return finalr;
end;

$function$
;
-- DROP FUNCTION public.user_transactions_for_user(int4, varchar);

create or replace
function public.user_transactions_for_user("USERID" integer,
"REFERENCENUMBER" character varying)
 returns table("TransactionId" character varying,
"UserId" integer,
"SubscriptionId" character varying,
"SubscriptionName" character varying,
"Status" character varying,
"RequestPayload" character varying,
"ResponsePayload" character varying,
"BankAlfalahSubscriptionId" character varying,
"CreatedAt" timestamp without time zone,
"UpdatedAt" timestamp without time zone,
"PromocodeId" character varying,
"ImageUrl" character varying,
"IsApproved" boolean,
"Country" character varying,
"Currency" character varying,
"Phone" character varying,
"Email" character varying,
"PortalId" integer,
"OrderId" character varying,
"TransactionReferenceNumber" character varying,
"TransactionAmount" character varying,
"TransactionDescription" character varying,
"TransactionStatus" character varying,
"ReferenceNumber" character varying,
"Location" character varying,
"BoughtByAndReason" text,
"SelfPaid" boolean)
 language plpgsql
as $function$
begin
    return QUERY
-- Self-paid transactions
    select
	ut.id as "TransactionId",
	ut.user_id as "UserId",
	ut.subscription_id as "SubscriptionId",
	s."name" as "SubscriptionName",
	ut.status as "Status",
	ut.request_payload as "RequestPayload",
	ut.response_payload as "ResponsePayload",
	ut.bank_alfalah_subscription_id as "BankAlfalahSubscriptionId",
	ut.created_at as "CreatedAt",
	ut.updated_at as "UpdatedAt",
	ut.promocode_id as "PromocodeId",
	ut.image_url as "ImageUrl",
	ut.is_approved as "IsApproved",
	ut.country as "Country",
	ut.currency as "Currency",
	ut.phone as "Phone",
	ut.email as "Email",
	ut.portal_id as "PortalId",
	ut.order_id as "OrderId",
	ut.transaction_reference_number as "TransactionReferenceNumber",
	ut.transaction_amount as "TransactionAmount",
	ut.transaction_description as "TransactionDescription",
	ut.transaction_status as "TransactionStatus",
	ut.reference_number as "ReferenceNumber",
	ut."location" as "Location",
	ut.bought_by_and_reason as "BoughtByAndReason",
	true as "SelfPaid"
from
	public.user_transactions ut
left join public.subscriptions s on
	ut.subscription_id = s.id
where
	ut.user_id = "USERID"
	and (ut.reference_number ilike "REFERENCENUMBER"
		or "REFERENCENUMBER" is null)
union all
-- Admin-paid transactions
    select
	wta.id as "TransactionId",
	wta.user_id as "UserId",
	wta.plan_id as "SubscriptionId",
	p.name as "SubscriptionName",
	null as "Status",
	null as "RequestPayload",
	null as "ResponsePayload",
	null as "BankAlfalahSubscriptionId",
	wta.created_at as "CreatedAt",
	null as "UpdatedAt",
	null as "PromocodeId",
	null as "ImageUrl",
	null as "IsApproved",
	null as "Country",
	null as "Currency",
	null as "Phone",
	null as "Email",
	null as "PortalId",
	null as "OrderId",
	null as "TransactionReferenceNumber",
	null as "TransactionAmount",
	null as "TransactionDescription",
	null as "TransactionStatus",
	null as "ReferenceNumber",
	null as "Location",
	a.name || ' (' || a.email || ')' as "BoughtByAndReason",
	false as "SelfPaid"
from
	public.whitelabel_transactions_account_usage wta
left join public.admins a on
	wta.admin_id = a.id
left join public.plans_for_whitelabels p on
	wta.plan_id = p.id
where
	wta.user_id = "USERID"
order by
	"CreatedAt" desc;
end;

$function$
;
-- DROP FUNCTION public.verify_email(varchar);

create or replace
function public.verify_email("EMAIL" character varying)
 returns boolean
 language plpgsql
as $function$
	  declare
	  rows_updated integer := 0;

begin
		  update
	public."users"
set
	is_email_verified = true
where
	email = $1;

get diagnostics rows_updated = ROW_COUNT;

return rows_updated > 0;
end;

$function$
;
-- DROP FUNCTION public.get_branch_account_transactions();
-- DROP FUNCTION public.get_branch_account_transactions();
-- DROP FUNCTION public.get_branch_account_transactions(integer);

create or replace
function public.get_branch_account_transactions("PORTALID" integer)
	returns table
	(
		"BranchAccountTransactioId" character varying,
		"AdminName" character varying,
		"Status" character varying,
		"BranchId" character varying,
		"BranchName" character varying,
		"PortalName" character varying,
		"PortalId" integer,
		"TransactionDate" timestamp
	)
	language plpgsql
as $function$
	begin
		return query
		select
	bat.id,
	a.name,
	bat.status,
	b.id,
	b.name,
	p.portal_name,
	p.id,
	bat.created_at
from
	public.branch_account_transactions bat
left join public.admins a on 
		bat.admin_id = a.id
left join public.branches b on
		bat.branch_id = b.id
left join public.portal p on
		bat.portal_id = p.id
where
	bat.portal_id = $1
order by
	b.id desc,
	bat.created_at
		;
end;

$function$
;

;